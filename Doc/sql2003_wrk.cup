
<SQL terminal character> ::= <SQL language character>

<SQL language character> ::= <simple Latin letter> | <digit> | SQL_special_character

<simple Latin letter> ::= <simple Latin upper case letter> | <simple Latin lower case letter>

<simple Latin upper case letter> ::=
		A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z

<simple Latin lower case letter> ::=
		a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z

<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

SQL_special_character ::= DOUBLE_QUOTE
	                    |   PERCENT
	                    |   AMPERSAND
	                    |   QUOTE
	                    |   LPAR
	                    |   RPAR
	                    |   ASTERISK
	                    |   PLUS
	                    |   COMMA
	                    |   MINUS
	                    |   DOT
	                    |   SOLIDUS
	                    |   COLON
	                    |   SEMICOLON
	                    |   LT
	                    |   EQ
	                    |   GT
	                    |   QUESTION
	                    |   LBRA
	                    |   RBRA
	                    |   CIRCUMFLEX
	                    |   UNDERSCORE
	                    |   BAR_VER
	                    |   LLLAVE
	                    |   RLLAVE
                      ;

left_bracket_or_trigraph ::= LBRA 
                         |   LBRA_TRI
                         ;

right_bracket_or_trigraph ::= RBRA 
                          |   RBRA_TRI
                          ;

token ::= nondelimiter_token 
      |   delimiter_token
      ;

nondelimiter_token ::= regular_identifier
	                 |   key_word
	                 |   unsigned_numeric_literal
	                 |   national_character_string_literal
	                 |   bit_string_literal
	                 |   hex_string_literal
	                 |   large_object_length_token
	                 |   multiplier
	                 ;

regular_identifier ::= identifier_body
                   ;

identifier_body ::= <identifier start> [ <identifier part>... ]

<identifier part> ::= <identifier start> | <identifier extend>

<identifier start> ::= !! See the Syntax Rules.

<identifier extend> ::= !! See the Syntax Rules.

large_object_length_token ::= <digit>... multiplier

multiplier ::= K | M | G

<delimited identifier> ::= DOUBLE_QUOTE <delimited identifier body> DOUBLE_QUOTE

<delimited identifier body> ::= <delimited identifier part>... 

<delimited identifier part> ::= <nondoublequote character> | <doublequote symbol>


<nondoublequote character> ::= !! See the Syntax Rules.

<doublequote symbol> ::= DOUBLE_QUOTE DOUBLE_QUOTE

delimiter_token ::=
		<character string literal>
	|	<date string>
	|	<time string>
	|	<timestamp string>
	|	<interval string>
	|	<delimited identifier>
	|	SQL_special_character
	|	NE
	|	GE
	|	LE
	|	CONCAT
	|	ARROW
	|	LBRA_TRI
	|	RBRA_TRI
	|	DBL_COLON
	|	DBL_DOT


<separator> ::= { <comment> | <white space> }...

<comment> ::= <simple comment> | <bracketed comment>

<simple comment> ::= <simple comment introducer> [ <comment character>... ] <newline>

<simple comment introducer> ::= MINUSMINUS [ MINUS... ]

<bracketed comment> ::=
		<bracketed comment introducer> <bracketed comment contents> <bracketed comment terminator>

<bracketed comment introducer> ::= <slash> ASTERISK

<bracketed comment terminator> ::= ASTERISK <slash>

<bracketed comment contents> ::= [ { <comment character> | <separator> }... ]

<comment character> ::= <nonquote character> | QUOTE

<newline> ::= !! See the Syntax Rules.


key_word ::= reserved_word 
         |   non_reserved_word
         ;

non_reserved_word ::= A
                  |   ABS
                  |   ABSOLUTE
                  |   ACTION
                  |   ADA
                  |   ADMIN
                  |   AFTER
                  |   ALWAYS
                  |   ASC
                  |   ASSERTION
                  |   ASSIGNMENT
                  |   ATTRIBUTE
                  |   ATTRIBUTES
                  |   AVG
                  |   BEFORE
                  |   BERNOULLI
                  |   BREADTH
                  |   C
                  |   CARDINALITY
                  |   CASCADE
                  |   CATALOG
                  |   CATALOG_NAME
                  |   CEIL
                  |   CEILING
                  |   CHAIN
                  |   CHARACTERISTICS
                  |   CHARACTERS
                  |   CHARACTER_LENGTH
                  |   CHARACTER_SET_CATALOG
                  |   CHARACTER_SET_NAME
                  |   CHARACTER_SET_SCHEMA
                  |   CHAR_LENGTH
                  |   CHECKED
                  |   CLASS_ORIGIN
                  |   COALESCE
                  |   COBOL
                  |   CODE_UNITS
                  |   COLLATION
                  |   COLLATION_CATALOG
                  |   COLLATION_NAME
                  |   COLLATION_SCHEMA
                  |   COLLECT
                  |   COLUMN_NAME
                  |   COMMAND_FUNCTION
                  |   COMMAND_FUNCTION_CODE
                  |   COMMITTED
                  |   CONDITION
                  |   CONDITION_NUMBER
                  |   CONNECTION_NAME
                  |   CONSTRAINTS
                  |   CONSTRAINT_CATALOG
                  |   CONSTRAINT_NAME
                  |   CONSTRAINT_SCHEMA
                  |   CONSTRUCTORS
                  |   CONTAINS
                  |   CONVERT
                  |   CORR
                  |   COUNT
                  |   COVAR_POP
                  |   COVAR_SAMP
                  |   CUME_DIST
                  |   CURRENT_COLLATION
                  |   CURSOR_NAME
                  |   DATA
                  |   DATETIME_INTERVAL_CODE
                  |   DATETIME_INTERVAL_PRECISION
                  |   DEFAULTS
                  |   DEFERRABLE
                  |   DEFERRED
                  |   DEFINED
                  |   DEFINER
                  |   DEGREE
                  |   DENSE_RANK
                  |   DEPTH
                  |   DERIVED
                  |   DESC
                  |   DESCRIPTOR
                  |   DIAGNOSTICS
                  |   DISPATCH
                  |   DOMAIN
                  |   DYNAMIC_FUNCTION
                  |   DYNAMIC_FUNCTION_CODE
                  |   EQUALS
                  |   EVERY
                  |   EXCEPTION
                  |   EXCLUDE
                  |   EXCLUDING
                  |   EXP
                  |   EXTRACT
                  |   FINAL
                  |   FIRST
                  |   FLOOR
                  |   FOLLOWING
                  |   FORTRAN
                  |   FOUND
                  |   FUSION
                  |   G
                  |   GENERAL
                  |   GO
                  |   GOTO
                  |   GRANTED
                  |   HIERARCHY
                  |   IMPLEMENTATION
                  |   INCLUDING
                  |   INCREMENT
                  |   INITIALLY
                  |   INSTANCE
                  |   INSTANTIABLE
                  |   INTERSECTION
                  |   INVOKER
                  |   ISOLATION
                  |   K
                  |   KEY
                  |   KEY_MEMBER
                  |   KEY_TYPE
                  |   LAST
                  |   LENGTH
                  |   LEVEL
                  |   LN
                  |   LOCATOR
                  |   LOWER
                  |   M
                  |   MAP
                  |   MATCHED
                  |   MAX
                  |   MAXVALUE
                  |   MESSAGE_LENGTH
                  |   MESSAGE_OCTET_LENGTH
                  |   MESSAGE_TEXT
                  |   MIN
                  |   MINVALUE
                  |   MOD
                  |   MORE
                  |   MUMPS
                  |   NAME
                  |   NAMES
                  |   NESTING
                  |   NEXT
                  |   NORMALIZE
                  |   NORMALIZED
                  |   NULLABLE
                  |   NULLIF
                  |   NULLS
                  |   NUMBER
                  |   OBJECT
                  |   OCTETS
                  |   OCTET_LENGTH
                  |   OPTION
                  |   OPTIONS
                  |   ORDERING
                  |   ORDINALITY
                  |   OTHERS
                  |   OVERLAY
                  |   OVERRIDING
                  |   PAD
                  |   PARAMETER_MODE
                  |   PARAMETER_NAME
                  |   PARAMETER_ORDINAL_POSITION
                  |   PARAMETER_SPECIFIC_CATALOG
                  |   PARAMETER_SPECIFIC_NAME
                  |   PARAMETER_SPECIFIC_SCHEMA
                  |   PARTIAL
                  |   PASCAL
                  |   PATH
                  |   PERCENTILE_CONT
                  |   PERCENTILE_DISC
                  |   PERCENT_RANK
                  |   PLACING
                  |   PLI
                  |   POSITION
                  |   POWER
                  |   PRECEDING
                  |   PRESERVE
                  |   PRIOR
                  |   PRIVILEGES
                  |   PUBLIC
                  |   RANK
                  |   READ
                  |   RELATIVE
                  |   REPEATABLE
                  |   RESTART
                  |   RETURNED_CARDINALITY
                  |   RETURNED_LENGTH
                  |   RETURNED_OCTET_LENGTH
                  |   RETURNED_SQLSTATE
                  |   ROLE
                  |   ROUTINE
                  |   ROUTINE_CATALOG
                  |   ROUTINE_NAME
                  |   ROUTINE_SCHEMA
                  |   ROW_COUNT
                  |   ROW_NUMBER
                  |   SCALE
                  |   SCHEMA
                  |   SCHEMA_NAME
                  |   SCOPE_CATALOG
                  |   SCOPE_NAME
                  |   SCOPE_SCHEMA
                  |   SECTION
                  |   SECURITY
                  |   SELF
                  |   SEQUENCE
                  |   SERIALIZABLE
                  |   SERVER_NAME
                  |   SESSION
                  |   SETS
                  |   SIMPLE
                  |   SIZE
                  |   SOURCE
                  |   SPACE
                  |   SPECIFIC_NAME
                  |   SQRT
                  |   STATE
                  |   STATEMENT
                  |   STDDEV_POP
                  |   STDDEV_SAMP
                  |   STRUCTURE
                  |   STYLE
                  |   SUBCLASS_ORIGIN
                  |   SUBSTRING
                  |   SUM
                  |   TABLESAMPLE
                  |   TABLE_NAME
                  |   TEMPORARY
                  |   TIES
                  |   TOP_LEVEL_COUNT
                  |   TRANSACTION
                  |   TRANSACTIONS_COMMITTED
                  |   TRANSACTIONS_ROLLED_BACK
                  |   TRANSACTION_ACTIVE
                  |   TRANSFORM
                  |   TRANSFORMS
                  |   TRANSLATE
                  |   TRIGGER_CATALOG
                  |   TRIGGER_NAME
                  |   TRIGGER_SCHEMA
                  |   TRIM
                  |   TYPE
                  |   UNBOUNDED
                  |   UNCOMMITTED
                  |   UNDER
                  |   UNNAMED
                  |   USAGE
                  |   USER_DEFINED_TYPE_CATALOG
                  |   USER_DEFINED_TYPE_CODE
                  |   USER_DEFINED_TYPE_NAME
                  |   USER_DEFINED_TYPE_SCHEMA
                  |   VIEW
                  |   WORK
                  |   WRITE
                  |   ZONE
                  ;

reserved_word ::= ADD
	            |   ALL
	            |   ALLOCATE
	            |   ALTER
	            |   AND
	            |   ANY
	            |   ARE
	            |   ARRAY
	            |   AS
	            |   ASENSITIVE
	            |   ASYMMETRIC
	            |   AT
	            |   ATOMIC
	            |   AUTHORIZATION
	            |   BEGIN
	            |   BETWEEN
	            |   BIGINT
	            |   BINARY
	            |   BLOB
	            |   BOOLEAN
	            |   BOTH
	            |   BY
	            |   CALL
	            |   CALLED
	            |   CASCADED
	            |   CASE
	            |   CAST
	            |   CHAR
	            |   CHARACTER
	            |   CHECK
	            |   CLOB
	            |   CLOSE
	            |   COLLATE
	            |   COLUMN
	            |   COMMIT
	            |   CONNECT
	            |   CONSTRAINT
	            |   CONTINUE
	            |   CORRESPONDING
	            |   CREATE
	            |   CROSS
	            |   CUBE
	            |   CURRENT
	            |   CURRENT_DATE
	            |   CURRENT_DEFAULT_TRANSFORM_GROUP
	            |   CURRENT_PATH
	            |   CURRENT_ROLE
	            |   CURRENT_TIME
	            |   CURRENT_TIMESTAMP
	            |   CURRENT_TRANSFORM_GROUP_FOR_TYPE
	            |   CURRENT_USER
	            |   CURSOR
	            |   CYCLE
	            |   DATE
	            |   DAY
	            |   DEALLOCATE
	            |   DEC
	            |   DECIMAL
	            |   DECLARE
	            |   DEFAULT
	            |   DELETE
	            |   DEREF
	            |   DESCRIBE
	            |   DETERMINISTIC
	            |   DISCONNECT
	            |   DISTINCT
	            |   DOUBLE
	            |   DROP
	            |   DYNAMIC
	            |   EACH
	            |   ELEMENT
	            |   ELSE
	            |   END
	            |   END-EXEC
	            |   ESCAPE
	            |   EXCEPT
	            |   EXEC
	            |   EXECUTE
	            |   EXISTS
	            |   EXTERNAL
	            |   FALSE
	            |   FETCH
	            |   FILTER
	            |   FLOAT
	            |   FOR
	            |   FOREIGN
	            |   FREE
	            |   FROM
	            |   FULL
	            |   FUNCTION
	            |   GET
	            |   GLOBAL
	            |   GRANT
	            |   GROUP
	            |   GROUPING
	            |   HAVING
	            |   HOLD
	            |   HOUR
	            |   IDENTITY
	            |   IMMEDIATE
	            |   IN
	            |   INDICATOR
	            |   INNER
	            |   INOUT
	            |   INPUT
	            |   INSENSITIVE
	            |   INSERT
	            |   INT
	            |   INTEGER
	            |   INTERSECT
	            |   INTERVAL
	            |   INTO
	            |   IS
	            |   ISOLATION
	            |   JOIN
	            |   LANGUAGE
	            |   LARGE
	            |   LATERAL
	            |   LEADING
	            |   LEFT
	            |   LIKE
	            |   LOCAL
	            |   LOCALTIME
	            |   LOCALTIMESTAMP
	            |   MATCH
	            |   MEMBER
	            |   MERGE
	            |   METHOD
	            |   MINUTE
	            |   MODIFIES
	            |   MODULE
	            |   MONTH
	            |   MULTISET
	            |   NATIONAL
	            |   NATURAL
	            |   NCHAR
	            |   NCLOB
	            |   NEW
	            |   NO
	            |   NONE
	            |   NOT
	            |   NULL
	            |   NUMERIC
	            |   OF
	            |   OLD
	            |   ON
	            |   ONLY
	            |   OPEN
	            |   OR
	            |   ORDER
	            |   OUT
	            |   OUTER
	            |   OUTPUT
	            |   OVER
	            |   OVERLAPS
	            |   PARAMETER
	            |   PARTITION
	            |   PRECISION
	            |   PREPARE
	            |   PRIMARY
	            |   PROCEDURE
	            |   RANGE
	            |   READS
	            |   REAL
	            |   RECURSIVE
	            |   REF
	            |   REFERENCES
	            |   REFERENCING
	            |   REGR_AVGX
	            |   REGR_AVGY
	            |   REGR_COUNT
	            |   REGR_INTERCEPT
	            |   REGR_R2
	            |   REGR_SLOPE
	            |   REGR_SXX
	            |   REGR_SXY
	            |   REGR_SYY
	            |   RELEASE
	            |   RESULT
	            |   RETURN
	            |   RETURNS
	            |   REVOKE
	            |   RIGHT
	            |   ROLLBACK
	            |   ROLLUP
	            |   ROW
	            |   ROWS
	            |   SAVEPOINT
	            |   SCROLL
	            |   SEARCH
	            |   SECOND
	            |   SELECT
	            |   SENSITIVE
	            |   SESSION_USER
	            |   SET
	            |   SIMILAR
	            |   SMALLINT
	            |   SOME
	            |   SPECIFIC
	            |   SPECIFICTYPE
	            |   SQL
	            |   SQLEXCEPTION
	            |   SQLSTATE
	            |   SQLWARNING
	            |   START
	            |   STATIC
	            |   SUBMULTISET
	            |   SYMMETRIC
	            |   SYSTEM
	            |   SYSTEM_USER
	            |   TABLE
	            |   THEN
	            |   TIME
	            |   TIMESTAMP
	            |   TIMEZONE_HOUR
	            |   TIMEZONE_MINUTE
	            |   TO
	            |   TRAILING
	            |   TRANSLATION
	            |   TREAT
	            |   TRIGGER
	            |   TRUE
	            |   UESCAPE
	            |   UNION
	            |   UNIQUE
	            |   UNKNOWN
	            |   UNNEST
	            |   UPDATE
	            |   UPPER
	            |   USER
	            |   USING
	            |   VALUE
	            |   VALUES
	            |   VAR_POP
	            |   VAR_SAMP
	            |   VARCHAR
	            |   VARYING
	            |   WHEN
	            |   WHENEVER
	            |   WHERE
	            |   WIDTH_BUCKET
	            |   WINDOW
	            |   WITH
	            |   WITHIN
	            |   WITHOUT
	            |   YEAR
              ;

<literal> ::= signed_numeric_literal | <general literal>

<unsigned literal> ::= unsigned_numeric_literal | <general literal>

<general literal> ::=
		<character string literal>
	|	national_character_string_literal
	|	<binary string literal>
	|	<datetime literal>
	|	<interval literal>
	|	<boolean literal>

<character string literal> ::=
		[ <introducer><character set specification> ]
		QUOTE [ <character representation>... ] QUOTE
		[ { <separator> QUOTE [ <character representation>... ] QUOTE }... ]

<introducer> ::= UNDERSCORE

<character representation> ::= <nonquote character> | <quote symbol>

<nonquote character> ::= !! See the Syntax Rules.


<quote symbol> ::= QUOTEQUOTE

national_character_string_literal ::=
		N QUOTE [ <character representation>... ] QUOTE
		[ { <separator> QUOTE [ <character representation>... ] QUOTE }... ]

<binary string literal> ::=
		X QUOTE [ { <hexit><hexit> }... ] QUOTE
		[ { <separator> QUOTE [ { <hexit><hexit> }... ] QUOTE }... ]
		[ ESCAPE <escape character> ]

<hexit> ::= <digit> | A | B | C | D | E | F | a | b | c | d | e | f

signed_numeric_literal ::= signo unsigned_numeric_literal
                       ;

unsigned_numeric_literal ::= exact_numeric_literal 
                         | approximate_numeric_literal
                         ;

exact_numeric_literal ::= parte_entera parte_decimal
                      |   valor_decimal
                      ;

parte_entera ::=  unsigned_integer
             ;
             
parte_decimal ::=  valor_decimal
              |
              ;
              
valor_decimal ::= DOT unsigned_integer
              ;

sign ::= PLUS 
     |   MINUS
     ;

approximate_numeric_literal ::= mantissa E exponent

mantissa ::= exact_numeric_literal
         ; 

exponent ::= signed_integer
         ;

signed_integer ::= signo unsigned_integer
               ;

signo ::= sign
      |
      ;
      
<datetime literal> ::= <date literal> | <time literal> | <timestamp literal>

<date literal> ::= DATE <date string>

<time literal> ::= TIME <time string>

<timestamp literal> ::= TIMESTAMP <timestamp string>

<date string> ::= QUOTE <unquoted date string> QUOTE

<time string> ::= QUOTE <unquoted time string> QUOTE

<timestamp string> ::= QUOTE <unquoted timestamp string> QUOTE

<time zone interval> ::= sign <hours value> COLON <minutes value>

<date value> ::= <years value> MINUS <months value> MINUS <days value>

<time value> ::= <hours value> COLON <minutes value> COLON <seconds value>

<interval literal> ::= INTERVAL [ sign ] <interval string> <interval qualifier>

<interval string> ::= QUOTE <unquoted interval string> QUOTE

<unquoted date string> ::= <date value>

<unquoted time string> ::= <time value> [ <time zone interval> ]

<unquoted timestamp string> ::= <unquoted date string> <space> <unquoted time string>

<unquoted interval string> ::= [ sign ] { <year-month literal> | <day-time literal> }

<year-month literal> ::= <years value> | [ <years value> MINUS ] <months value>

<day-time literal> ::= <day-time interval> | <time interval>

<day-time interval> ::=
		<days value> [ <space> <hours value> [ COLON <minutes value> [ COLON <seconds value> ] ] ]

<time interval> ::=
		<hours value> [ COLON <minutes value> [ COLON <seconds value> ] ]
	|	<minutes value> [ COLON <seconds value> ]
	|	<seconds value>

<years value> ::= <datetime value>

<months value> ::= <datetime value>

<days value> ::= <datetime value>

<hours value> ::= <datetime value>

<minutes value> ::= <datetime value>

<seconds value> ::= <seconds integer value> [ DOT [ <seconds fraction> ] ]

<seconds integer value> ::= unsigned_integer

<seconds fraction> ::= unsigned_integer

<datetime value> ::= unsigned_integer

<boolean literal> ::= TRUE | FALSE | UNKNOWN

--hr
--h3 5.4 Names and identifiers (p151)
--/h3

<identifier> ::= <actual identifier>

<actual identifier> ::= regular_identifier | <delimited identifier>

<SQL language identifier> ::=
		<SQL language identifier start> [ { UNDERSCORE | <SQL language identifier part> }... ]

<SQL language identifier start> ::= <simple Latin letter>

<SQL language identifier part> ::= <simple Latin letter> | <digit>

<authorization identifier> ::= <role name> | <user identifier>

<table name> ::= <local or schema qualified name>

<domain name> ::= <schema qualified name>

<schema name> ::= [ <catalog name> DOT ] <unqualified schema name>

<catalog name> ::= <identifier>

<schema qualified name> ::= [ <schema name> DOT ] <qualified identifier>

<local or schema qualified name> ::= [ <local or schema qualifier> DOT ] <qualified identifier>

<local or schema qualifier> ::= <schema name> | MODULE

<qualified identifier> ::= <identifier>

<column name> ::= <identifier>

<correlation name> ::= <identifier>

<query name> ::= <identifier>

<SQL-client module name> ::= <identifier>

<procedure name> ::= <identifier>

<schema qualified routine name> ::= <schema qualified name>

<method name> ::= <identifier>

<specific name> ::= <schema qualified name>

<cursor name> ::= <local qualified name>

<local qualified name> ::= [ <local qualifier> DOT ] <qualified identifier>

<local qualifier> ::= MODULE

<host parameter name> ::= COLON <identifier>

<SQL parameter name> ::= <identifier>

constraint_name ::= <schema qualified name>

<external routine name> ::= <identifier> | <character string literal>

<trigger name> ::= <schema qualified name>

<collation name> ::= <schema qualified name>

<character set name> ::= [ <schema name> DOT ] <SQL language identifier>

<transliteration name> ::= <schema qualified name>

<transcoding name> ::= <schema qualified name>

<user-defined type name> ::= <schema qualified type name>

<schema-resolved user-defined type name> ::= <user-defined type name>

<schema qualified type name> ::= [ <schema name> DOT ] <qualified identifier>

<attribute name> ::= <identifier>

<field name> ::= <identifier>

<savepoint name> ::= <identifier>

<sequence generator name> ::= <schema qualified name>

<role name> ::= <identifier>

<user identifier> ::= <identifier>

<connection name> ::= simple_value_specification

<SQL-server name> ::= simple_value_specification

<connection user name> ::= simple_value_specification

<SQL statement name> ::= <statement name> | <extended statement name>

<statement name> ::= <identifier>

<extended statement name> ::= [ <scope option> ] simple_value_specification

<dynamic cursor name> ::= <cursor name> | <extended cursor name>

<extended cursor name> ::= [ <scope option> ] simple_value_specification

<descriptor name> ::= [ <scope option> ] simple_value_specification

<scope option> ::= GLOBAL | LOCAL

<window name> ::= <identifier>

--hr
--h2 6 Scalar expressions
--/h2

--h3 6.1 <data type> (p161)
--/h3

<data type> ::=
		<predefined type>
	|	<row type>
	|	<path-resolved user-defined type name>
	|	<reference type>
	|	<collection type>

<predefined type> ::=
		<character string type> [ CHARACTER SET <character set specification> ] [ <collate clause> ]
	|	<national character string type> [ <collate clause> ]
	|	<binary large object string type>
	|	<numeric type>
	|	<boolean type>
	|	<datetime type>
	|	<interval type>

<character string type> ::=
		CHARACTER [ LPAR <length> RPAR ]
	|	CHAR [ LPAR <length> RPAR ]
	|	CHARACTER VARYING LPAR <length> RPAR
	|	CHAR VARYING LPAR <length> RPAR
	|	VARCHAR LPAR <length> RPAR
	|	CHARACTER LARGE OBJECT [ LPAR <large object length> RPAR ]
	|	CHAR LARGE OBJECT [ LPAR <large object length> RPAR ]
	|	CLOB [ LPAR <large object length> RPAR ]

<national character string type> ::=
		NATIONAL CHARACTER [ LPAR <length> RPAR ]
	|	NATIONAL CHAR [ LPAR <length> RPAR ]
	|	NCHAR [ LPAR <length> RPAR ]
	|	NATIONAL CHARACTER VARYING LPAR <length> RPAR
	|	NATIONAL CHAR VARYING LPAR <length> RPAR
	|	NCHAR VARYING LPAR <length> RPAR
	|	NATIONAL CHARACTER LARGE OBJECT [ LPAR <large object length> RPAR ]
	|	NCHAR LARGE OBJECT [ LPAR <large object length> RPAR ]
	|	NCLOB [ LPAR <large object length> RPAR ]

<binary large object string type> ::=
		BINARY LARGE OBJECT [ LPAR <large object length> RPAR ]
	|	BLOB [ LPAR <large object length> RPAR ]

<numeric type> ::= <exact numeric type> | <approximate numeric type>

<exact numeric type> ::=
		NUMERIC [ LPAR <precision> [ COMMA <scale> ] RPAR ]
	|	DECIMAL [ LPAR <precision> [ COMMA <scale> ] RPAR ]
	|	DEC [ LPAR <precision> [ COMMA <scale> ] RPAR ]
	|	SMALLINT
	|	INTEGER
	|	INT
	|	BIGINT

<approximate numeric type> ::=
		FLOAT [ LPAR <precision> RPAR ]
	|	REAL
	|	DOUBLE PRECISION

<length> ::= unsigned_integer

<large object length> ::=
		unsigned_integer [ multiplier ] [ <char length units> ]
	|	large_object_length_token [ <char length units> ]

<char length units> ::= CHARACTERS | CODE_UNITS | OCTETS

<precision> ::= unsigned_integer

<scale> ::= unsigned_integer

<boolean type> ::= BOOLEAN

<datetime type> ::=
		DATE
	|	TIME [ LPAR <time precision> RPAR ] [ <with or without time zone> ]
	|	TIMESTAMP [ LPAR <timestamp precision> RPAR ] [ <with or without time zone> ]

<with or without time zone> ::= WITH TIME ZONE | WITHOUT TIME ZONE

<time precision> ::= <time fractional seconds precision>

<timestamp precision> ::= <time fractional seconds precision>

<time fractional seconds precision> ::= unsigned_integer

<interval type> ::= INTERVAL <interval qualifier>

<row type> ::= ROW <row type body>

<row type body> ::= LPAR <field definition> [ { COMMA <field definition> }... ] RPAR

<reference type> ::= REF LPAR <referenced type> RPAR [ <scope clause> ]

<scope clause> ::= SCOPE <table name>

<referenced type> ::= <path-resolved user-defined type name>

<path-resolved user-defined type name> ::= <user-defined type name>

<path-resolved user-defined type name> ::= <user-defined type name>

<collection type> ::= <array type> | <multiset type>

<array type> ::= <data type> ARRAY [ left_bracket_or_trigraph unsigned_integer right_bracket_or_trigraph ]

<multiset type> ::= <data type> MULTISET

--hr
--h3 6.2 <field definition> (p173)
--/h3

<field definition> ::= <field name> <data type> [ <reference scope check> ]

--hr
--h3 6.3 <value expression primary> (p174)
--/h3

<value expression primary> ::=
		<parenthesized value expression>
	|	<nonparenthesized value expression primary>

<parenthesized value expression> ::= LPAR <value expression> RPAR

<nonparenthesized value expression primary> ::=
		<unsigned value specification>
	|	<column reference>
	|	<set function specification>
	|	<window function>
	|	<scalar subquery>
	|	<case expression>
	|	<cast specification>
	|	<field reference>
	|	<subtype treatment>
	|	<method invocation>
	|	<static method invocation>
	|	<new specification>
	|	<attribute or method reference>
	|	<reference resolution>
	|	<collection value constructor>
	|	<array element reference>
	|	<multiset element reference>
	|	<routine invocation>
	|	<next value expression>

--hr
--h3 6.4 <value specification> and <target specification> (p176)
--/h3

<value specification> ::= <literal> | <general value specification>

<unsigned value specification> ::= <unsigned literal> | <general value specification>

<general value specification> ::=
		<host parameter specification>
	|	<SQL parameter reference>
	|	<dynamic parameter specification>
	|	<embedded variable specification>
	|	<current collation specification>
	|	CURRENT_DEFAULT_TRANSFORM_GROUP
	|	CURRENT_PATH
	|	CURRENT_ROLE
	|	CURRENT_TRANSFORM_GROUP_FOR_TYPE <path-resolved user-defined type name>
	|	CURRENT_USER
	|	SESSION_USER
	|	SYSTEM_USER
	|	USER
	|	VALUE

simple_value_specification ::=
		<literal>
	|	<host parameter name>
	|	<SQL parameter reference>
	|	<embedded variable name>

<target specification> ::=
		<host parameter specification>
	|	<SQL parameter reference>
	|	<column reference>
	|	<target array element specification>
	|	<dynamic parameter specification>
	|	<embedded variable specification>

simple_target_specification ::=
		<host parameter specification>
	|	<SQL parameter reference>
	|	<column reference>
	|	<embedded variable name>

<host parameter specification> ::= <host parameter name> [ <indicator parameter> ]

<dynamic parameter specification> ::= QUESTION

<embedded variable specification> ::= <embedded variable name> [ <indicator variable> ]

<indicator variable> ::= [ INDICATOR ] <embedded variable name>

<indicator parameter> ::= [ INDICATOR ] <host parameter name>

<target array element specification> ::=
		<target array reference> left_bracket_or_trigraph simple_value_specification right_bracket_or_trigraph 

<target array reference> ::= <SQL parameter reference> | <column reference>

<current collation specification> ::= CURRENT_COLLATION LPAR <string value expression> RPAR

--hr
--h3 6.5 <contextually typed value specification> (p181)
--/h3

<contextually typed value specification> ::=
		<implicitly typed value specification> | <default specification>

<implicitly typed value specification> ::= <null specification> | <empty specification>

<null specification> ::= NULL

<empty specification> ::=
		ARRAY left_bracket_or_trigraph right_bracket_or_trigraph
	|	MULTISET left_bracket_or_trigraph right_bracket_or_trigraph

<default specification> ::= DEFAULT

--hr
--h3 6.6 <identifier chain> (p183)
--/h3

<identifier chain> ::= <identifier> [ { DOT <identifier> }... ]

<basic identifier chain> ::= <identifier chain>

--hr
--h3 6.7 <column reference> (p187)
--/h3

<column reference> ::=
		<basic identifier chain>
	|	MODULE DOT <qualified identifier> DOT <column name>

--hr
--h3 6.8 <SQL parameter reference> (p190)
--/h3

<SQL parameter reference> ::= <basic identifier chain>

--hr
--h3 6.9 <set function specification> (p191)
--/h3

<set function specification> ::= <aggregate function> | <grouping operation>

<grouping operation> ::= GROUPING LPAR <column reference> [ { COMMA <column reference> }... ] RPAR

--hr
--h3 6.10 <window function> (p193)
--/h3

<window function> ::= <window function type> OVER <window name or specification>

<window function type> ::=
		<rank function type> LPAR RPAR
	|	ROW_NUMBER LPAR RPAR
	|	<aggregate function>

<rank function type> ::= RANK | DENSE_RANK | PERCENT_RANK | CUME_DIST

<window name or specification> ::= <window name> | <in-line window specification>

<in-line window specification> ::= <window specification>

--hr
--h3 6.11 <case expression> (p197)
--/h3


<case expression> ::= <case abbreviation> | <case specification>

<case abbreviation> ::=
		NULLIF LPAR <value expression> COMMA <value expression> RPAR
	|	COALESCE LPAR <value expression> { COMMA <value expression> }... RPAR

<case specification> ::= <simple case> | <searched case>

<simple case> ::= CASE <case operand> <simple when clause>... [ <else clause> ] END

<searched case> ::= CASE <searched when clause>... [ <else clause> ] END

<simple when clause> ::= WHEN <when operand> THEN <result>

<searched when clause> ::= WHEN <search condition> THEN <result>

<else clause> ::= ELSE <result>

<case operand> ::= <row value predicand> | <overlaps predicate part>

<when operand> ::=
		<row value predicand>
	|	<comparison predicate part 2>
	|	<between predicate part 2>
	|	<in predicate part 2>
	|	<character like predicate part 2>
	|	<octet like predicate part 2>
	|	<similar predicate part 2>
	|	<null predicate part 2>
	|	<quantified comparison predicate part 2>
	|	<match predicate part 2>
	|	<overlaps predicate part 2>
	|	<distinct predicate part 2>
	|	<member predicate part 2>
	|	<submultiset predicate part 2>
	|	<set predicate part 2>
	|	<type predicate part 2>

<result> ::= <result expression> | NULL

<result expression> ::= <value expression>

--hr
--h3 6.12 <cast specification> (p200)
--/h3

<cast specification> ::= CAST LPAR <cast operand> AS <cast target> RPAR

<cast operand> ::= <value expression> | <implicitly typed value specification>

<cast target> ::= <domain name> | <data type>

--hr
--h3 6.13 <next value expression> (p216)
--/h3

<next value expression> ::= NEXT VALUE FOR <sequence generator name>

--hr
--h3 6.14 <field reference> (p218)
--/h3

<field reference> ::= <value expression primary> DOT <field name>

--hr
--h3 6.15 <subtype treatment> (p219)
--/h3

<subtype treatment> ::=
		TREAT LPAR <subtype operand> AS <target subtype> RPAR

<subtype operand> ::= <value expression>

<target subtype> ::=
		<path-resolved user-defined type name>
	|	<reference type>

--hr
--h3 6.16 <method invocation> (p221)
--/h3

<method invocation> ::= <direct invocation> | <generalized invocation>

<direct invocation> ::=
		<value expression primary> DOT <method name> [ <SQL argument list> ]

<generalized invocation> ::=
		LPAR <value expression primary> AS <data type> RPAR DOT <method name>
		[ <SQL argument list> ]

<method selection> ::= <routine invocation>

<constructor method selection> ::= <routine invocation>

--hr
--h3 6.17 <static method invocation> (p223)
--/h3

<static method invocation> ::=
		<path-resolved user-defined type name> DBL_COLON <method name> [ <SQL argument list> ]

<static method selection> ::= <routine invocation>

--hr
--h3 6.18 <new specification> (p225)
--/h3

<new specification> ::= NEW <routine invocation>

<new invocation> ::= <method invocation> | <routine invocation>

--hr
--h3 6.19 <attribute or method reference> (p227)
--/h3

<attribute or method reference> ::=
		<value expression primary> <dereference operator> <qualified identifier>
		[ <SQL argument list> ]

<dereference operator> ::= ARROW

--hr
--h3 6.20 <dereference operation> (p229)
--/h3

<dereference operation> ::= <reference value expression> <dereference operator> <attribute name>

--hr
--h3 6.21 <method reference> (p230)
--/h3

<method reference> ::=
		<value expression primary> <dereference operator> <method name> <SQL argument list>

--hr
--h3 6.22 <reference resolution> (p232)
--/h3

<reference resolution> ::= DEREF LPAR <reference value expression> RPAR

--hr
--h3 6.23 <array element reference> (p234)
--/h3

<array element reference> ::=
		<array value expression> left_bracket_or_trigraph <numeric value expression> right_bracket_or_trigraph 

--hr
--h3 6.24 <multiset element reference> (p235)
--/h3
	
<multiset element reference> ::=
		ELEMENT LPAR <multset value expression> RPAR

--h3 6.25 <value expression> (p236)
--/h3

/*
Specify a value.
*/

<value expression> ::=
		<common value expression>
	|	<boolean value expression>
	|	<row value expression>

<common value expression> ::=
		<numeric value expression>
	|	<string value expression>
	|	<datetime value expression>
	|	<interval value expression>
	|	<user-defined type value expression>
	|	<reference value expression>
	|	<collection value expression>

<user-defined type value expression> ::= <value expression primary>

<reference value expression> ::= <value expression primary>

<collection value expression> ::= <array value expression> | <multiset value expression>

<collection value constructor> ::= <array value constructor> | <multiset value constructor>

--h3 6.26 <numeric value expression> (p240)
--/h3

/*
Specify a numeric value.
*/

<numeric value expression> ::=
		<term>
	|	<numeric value expression> PLUS <term>
	|	<numeric value expression> MINUS <term>

<term> ::=
		<factor>
	|	<term> ASTERISK <factor>
	|	<term> SOLIDUS <factor>

<factor> ::= [ sign ] <numeric primary>

<numeric primary> ::=
		<value expression primary>
	|	<numeric value function>

--h3 6.27 <numeric value function> (p242)
--/h3

/*
Specify a function yielding a value of type numeric.
*/

<numeric value function> ::=
		<position expression>
	|	<extract expression>
	|	<length expression>
	|	<cardinality expression>
	|	<absolute value expression>
	|	<modulus expression>
	|	<natural logarithm>
	|	<exponential function>
	|	<power function>
	|	<square root>
	|	<floor function>
	|	<ceiling function>
	|	<width bucket function>

<position expression> ::=
		<string position expression>
	|	<blob position expression>

<string position expression> ::=
		POSITION LPAR <string value expression> IN <string value expression> [ USING <char length units> ] RPAR

<blob position expression> ::=
		POSITION LPAR <blob value expression> IN <blob value expression> RPAR

<length expression> ::=
		<char length expression>
	|	<octet length expression>

<char length expression> ::=
		{ CHAR_LENGTH | CHARACTER_LENGTH } LPAR <string value expression> [ USING <char length units> ] RPAR

<octet length expression> ::= OCTET_LENGTH LPAR <string value expression> RPAR

<extract expression> ::= EXTRACT LPAR <extract field> FROM <extract source> RPAR

<extract field> ::= <primary datetime field> | <time zone field>

<time zone field> ::= TIMEZONE_HOUR | TIMEZONE_MINUTE

<extract source> ::= <datetime value expression> | <interval value expression>

<cardinality expression> ::= CARDINALITY LPAR <collection value expression> RPAR

<absolute value expression> ::= ABS LPAR <numeric value expression> RPAR

<modulus expression> ::= MOD LPAR <numeric value expression dividend> COMMA <numeric value expression divisor>RPAR

<natural logarithm> ::= LN LPAR <numeric value expression> RPAR

<exponential function> ::= EXP LPAR <numeric value expression> RPAR

<power function> ::= POWER LPAR <numeric value expression base> COMMA <numeric value expression exponent> RPAR

<numeric value expression base> ::= <numeric value expression>

<numeric value expression exponent> ::= <numeric value expression>

<square root> ::= SQRT LPAR <numeric value expression> RPAR

<floor function> ::= FLOOR LPAR <numeric value expression> RPAR

<ceiling function> ::= { CEIL | CEILING } LPAR <numeric value expression> RPAR

<width bucket function> ::= WIDTH_BUCKET LPAR <width bucket operand> COMMA <width bucket bound 1> COMMA <width bucket bound 2> COMMA <width bucket count> RPAR

<width bucket operand> ::= <numeric value expression>

<width bucket bound 1> ::= <numeric value expression>

<width bucket bound 2> ::= <numeric value expression>

<width bucket count> ::= <numeric value expression>

--h3 6.28 <string value expression> (p251)
--/h3

/*
Specify a character string value or a binary string value.
*/

<string value expression> ::= <character value expression> | <blob value expression>

<character value expression> ::= <concatenation> | <character factor>

<concatenation> ::= <character value expression> CONCAT <character factor>

<character factor> ::= <character primary> [ <collate clause> ]

<character primary> ::= <value expression primary> | <string value function>

<blob value expression> ::= <blob concatenation> | <blob factor>

<blob factor> ::= <blob primary>

<blob primary> ::= <value expression primary> | <string value function>

<blob concatenation> ::= <blob value expression> CONCAT <blob factor>

--h3 6.29 <string value function> (p255)
--/h3

/*
Specify a function yielding a value of type character string or binary string.
*/

<string value function> ::= <character value function> | <blob value function>

<character value function> ::=
		<character substring function>
	|	<regular expression substring function>
	|	<fold>
	|	<transcoding>
	|	<character transliteration>
	|	<trim function>
	|	<character overlay function>
	|	<normalize function>
	|	<specific type method>

<character substring function> ::=
		SUBSTRING LPAR <character value expression> FROM <start position>
		[ FOR <string length> ] [ USING <char length units> ] RPAR

<regular expression substring function> ::=
		SUBSTRING LPAR <character value expression>
		SIMILAR <character value expression> ESCAPE <escape character> RPAR

<fold> ::= { UPPER | LOWER } LPAR <character value expression> RPAR

<transcoding> ::= CONVERT LPAR <character value expression> USING <transcoding name> RPAR

<character transliteration> ::= TRANSLATE LPAR <character value expression> USING <transliteration name> RPAR

<trim function> ::= TRIM LPAR <trim operands> RPAR

<trim operands> ::= [ [ <trim specification> ] [ <trim character> ] FROM ] <trim source>

<trim source> ::= <character value expression>

<trim specification> ::= LEADING | TRAILING | BOTH

<trim character> ::= <character value expression>

<character overlay function> ::= 
		OVERLAY LPAR <character value expression> PLACING <character value expression>
		FROM <start position> [ FOR <string length> ] [ USING <char length units> ] RPAR

<normalize function> ::= NORMALIZE LPAR <character value expression> RPAR

<specific type method> ::= <user-defined type value expression> DOT SPECIFICTYPE

<blob value function> ::=
		<blob substring function>
	|	<blob trim function>
	|	<blob overlay function>

<blob substring function> ::=
		SUBSTRING LPAR <blob value expression> FROM <start position> [ FOR <string length> ] RPAR

<blob trim function> ::= TRIM LPAR <blob trim operands> RPAR

<blob trim operands> ::= [ [ <trim specification> ] [ <trim octet> ] FROM ] <blob trim source>

<blob trim source> ::= <blob value expression>

<trim octet> ::= <blob value expression>

<blob overlay function> ::=
		OVERLAY LPAR <blob value expression> PLACING <blob value expression>
		FROM <start position> [ FOR <string length> ] RPAR

<start position> ::= <numeric value expression>

<string length> ::= <numeric value expression>

--h3 6.30 <datetime value expression> (p266)
--/h3

/*
Specify a datetime value.
*/

<datetime value expression> ::=
		<datetime term>
	|	<interval value expression> PLUS <datetime term>
	|	<datetime value expression> PLUS <interval term>
	|	<datetime value expression> MINUS <interval term>

<datetime term> ::= <datetime factor>

<datetime factor> ::= <datetime primary> [ <time zone> ]

<datetime primary> ::= <value expression primary> | <datetime value function>

<time zone> ::= AT <time zone specifier>

<time zone specifier> ::= LOCAL | TIME ZONE <interval primary>

--h3 6.31 <datetime value function> (p269)
--/h3

/*
Specify a function yielding a value of type datetime.
*/

<datetime value function> ::=
		<current date value function>
	|	<current time value function>
	|	<current timestamp value function>
	|	<current local time value function>
	|	<current local timestamp value function>

<current date value function> ::= CURRENT_DATE

<current time value function> ::= CURRENT_TIME [ LPAR <time precision> RPAR ]

<current local time value function> ::= LOCALTIME [ LPAR <time precision> RPAR ]

<current timestamp value function> ::= CURRENT_TIMESTAMP [ LPAR <timestamp precision> RPAR ]

<current local timestamp value function> ::= LOCALTIMESTAMP [ LPAR <timestamp precision> RPAR ]

--h3 6.32 <interval value expression> (p271)
--/h3

/* 
Specify an interval value.
*/

<interval value expression> ::=
		<interval term>
	|	<interval value expression 1> PLUS <interval term 1>
	|	<interval value expression 1> MINUS <interval term 1>
	|	LPAR <datetime value expression> MINUS <datetime term> RPAR <interval qualifier>

<interval term> ::=
		<interval factor>
	|	<interval term 2> ASTERISK <factor>
	|	<interval term 2> SOLIDUS <factor>
	|	<term> ASTERISK <interval factor>

<interval factor> ::= [ sign ] <interval primary>

<interval primary> ::=
		<value expression primary> [ <interval qualifier> ]
	|	<interval value function>

<interval value expression 1> ::= <interval value expression>

<interval term 1> ::= <interval term>

<interval term 2> ::= <interval term>

--h3 6.33 <interval value function> (p276)
--/h3

<interval value function> ::= <interval absolute value function>

<interval absolute value function> ::= ABS LPAR <interval value expression> RPAR

--h3 6.34 <boolean value expression> (p277)
--/h3

<boolean value expression> ::=
		<boolean term>
	|	<boolean value expression> OR <boolean term>

<boolean term> ::=
		<boolean factor>
	|	<boolean term> AND <boolean factor>

<boolean factor> ::= [ NOT ] <boolean test>

<boolean test> ::= <boolean primary> [ IS [ NOT ] <truth value> ]

<truth value> ::= TRUE | FALSE | UNKNOWN

<boolean primary> ::= <predicate> | <boolean predicand>

<boolean predicand> ::=
		<parenthesized boolean value expression>
	|	<nonparenthesized value expression primary>

<parenthesized boolean value expression> ::= LPAR <boolean value expression> RPAR

--h3 6.35 <array value expression> (p284)
--/h3

<array value expression> ::= <array concatenation> | <array factor>

<array concatenation> ::= <array value expression 1> CONCAT <array factor>

<array value expression 1> ::= <array value expression>

<array factor> ::= <value expression primary>

--h3 6.36 <array value constructor> (p284)
--/h3

<array value constructor> ::=
		<array value constructor by enumeration>
	|	<array value constructor by query>

<array value constructor by enumeration> ::=
		ARRAY left_bracket_or_trigraph <array element list> right_bracket_or_trigraph

<array element list> ::= <array element> [ { COMMA <array element> }... ]

<array element> ::= <value expression>

<array value constructor by query> ::=
		ARRAY LPAR <query expression> [ <order by clause> ] RPAR

--h3 6.37 <multiset value expression> (p286)
--/h3

<multiset value expression> ::=
		<multiset term>
	|	<multiset value expression> MULTISET UNION [ ALL | DISTINCT ] <multiset term>
	|	<multiset value expression> MULTISET EXCEPT [ ALL | DISTINCT ] <multiset term>

<multiset term> ::=
		<multiset primary>
	|	<multiset term> MULTISET INTERSECT [ ALL | DISTINCT ] <multiset primary>

<multiset primary> ::= <multiset value function> | <value expression primary>

--h3 6.38 <multiset value function> (p289)
--/h3

<multiset value function> ::= <multiset set function>

<multiset set function> ::= SET LPAR <multiset value expression> RPAR

--h3 6.39 <multiset value constructor> (p290)
--/h3

<multiset value constructor> ::=
		<multiset value constructor by enumeration>
	|	<multiset value constructor by query>
	|	<table value constructor by query>

<multiset value constructor by enumeration> ::= MULTISET left_bracket_or_trigraph <multiset element list> right_bracket_or_trigraph

<multiset element list> ::= <multiset element> [ { COMMA <multiset element> } ]

<multiset element> ::= <value expression>

<multiset value constructor by query> ::= MULTISET LPAR <query expression> RPAR

<table value constructor by query> ::= TABLE LPAR <query expression> RPAR

--hr
--h2 7 Query expressions
--/h2

--h3 7.1 <row value constructor> (p293)
--/h3

/*
Specify a value or list of values to be constructed into a row or partial row.
*/

<row value constructor> ::=
		<common value expression>
	|	<boolean value expression>
	|	<explicit row value constructor>

<explicit row value constructor> ::=
		LPAR <row value constructor element> COMMA <row value constructor element list> RPAR
	|	ROW LPAR <row value constructor element list> RPAR
	|	<row subquery>

<row value constructor element list> ::=
		<row value constructor element> [ { COMMA <row value constructor element> }... ]

<row value constructor element> ::= <value expression>

<contextually typed row value constructor> ::=
		<common value expression>
	|	<boolean value expression>
	|	<contextually typed value specification>
	|	LPAR <contextually typed row value constructor element> COMMA <contextually typed row value constructor element list> RPAR
	|	ROW LPAR <contextually typed row value constructor element list> RPAR

<contextually typed row value constructor element list> ::=
		<contextually typed row value constructor element>
		[ { COMMA <contextually typed row value constructor element> }... ]

<contextually typed row value constructor element> ::=
		<value expression>
	|	<contextually typed value specification>

<row value constructor predicand> ::=
		<common value expression>
	|	<boolean predicand>
	|	<explicit row value constructor>

--h3 7.2 <row value expression> (p296)
--/h3

/* 
Specify a row value.
*/

<row value expression> ::=
		<row value special case>
	|	<explicit row value constructor>

<table row value expression> ::=
		<row value special case>
	|	<row value constructor>

<contextually typed row value expression> ::=
		<row value special case>
	|	<contextually typed row value constructor>

<row value predicand> ::=
		<row value special case>
	|	<row value constructor predicand>

<row value special case> ::= <nonparenthesized value expression primary>

--h3 7.3 <table value constructor> (p298)
--/h3

/* 
Specify a set of <row value expression>s to be constructed into a table.
*/

<table value constructor> ::= VALUES <row value expression list>

<row value expression list> ::= <table row value expression> [ { COMMA <table row value expression> }... ]

<contextually typed table value constructor> ::= VALUES <contextually typed row value expression list>

<contextually typed row value expression list> ::= <contextually typed row value expression> [ { COMMA <contextually typed row value expression> }... ]

--h3 7.4 <table expression> (p300)
--/h3

/* 
Specify a table or a grouped table.
*/

<table expression> ::=
		<from clause>
		[ <where clause> ]
		[ <group by clause> ]
		[ <having clause> ]
		[ <window clause> ]

--h3 7.5 <from clause> (p301)
--/h3

/* 
Specify a table derived from one or more tables.
*/

<from clause> ::= FROM <table reference list>

<table reference list> ::= <table reference> [ { COMMA <table reference> }... ]

--h3 7.6 <table reference> (p303)
--/h3

/* 
Reference a table.
*/

<table reference> ::= <table primary or joined table> [ <sample clause> ]

<table primary or joined table> ::= <table primary> | <joined table>

<sample clause> ::=
		TABLESAMPLE <sample method> LPAR <sample percentage> RPAR [ <repeatable clause> ]

<sample method> ::= BERNOULLI | SYSTEM

<repeatable clause> ::= REPEATABLE LPAR <repeat argument> RPAR

<sample percentage> ::= <numeric value expression>

<repeat argument> ::= <numeric value expression>

<table primary> ::=
		<table or query name> [ [ AS ] <correlation name> [ LPAR <derived column list> RPAR ] ]
	|	<derived table> [ AS ] <correlation name> [ LPAR <derived column list> RPAR ]
	|	<lateral derived table> [ AS ] <correlation name> [ LPAR <derived column list> RPAR ]
	|	<collection derived table> [ AS ] <correlation name> [ LPAR <derived column list> RPAR ]
	|	<table function derived table> [ AS ] <correlation name> [ LPAR <derived column list> RPAR ]
	|	<only spec> [ [ AS ] <correlation name> [ LPAR <derived column list> RPAR ] ]
	|	LPAR <joined table> RPAR

<only spec> ::= ONLY LPAR <table or query name> RPAR

<lateral derived table> ::= LATERAL <table subquery>

<collection derived table> ::= UNNEST LPAR <collection value expression> RPAR [ WITH ORDINALITY ]

<table function derived table> ::= TABLE LPAR <collection value expression> RPAR

<derived table> ::= <table subquery>

<table or query name> ::= <table name> | <query name>

<derived column list> ::= <column name list>

<column name list> ::= <column name> [ { COMMA <column name> }... ]

--h3 7.7 <joined table> (p312)
--/h3

/* 
Specify a table derived from a Cartesian product, inner or outer join, or union join.
*/

<joined table> ::=
		<cross join>
	|	<qualified join>
	|	<natural join>
	|	<union join>

<cross join> ::= <table reference> CROSS JOIN <table primary>

<qualified join> ::= <table reference> [ <join type> ] JOIN <table reference> <join specification>

<natural join> ::= <table reference> NATURAL [ <join type> ] JOIN <table primary>

<union join> ::= <table reference> UNION JOIN <table primary>

<join specification> ::= <join condition> | <named columns join>

<join condition> ::= ON <search condition>

<named columns join> ::= USING LPAR <join column list> RPAR

<join type> ::= INNER | <outer join type> [ OUTER ] 

<outer join type> ::= LEFT | RIGHT | FULL

<join column list> ::= <column name list>

--h3 7.8 <where clause> (p319)
--/h3

/* 
Specify a table derived by the application of a <search condition> to the result of the preceding
<from clause>.
*/

<where clause> ::= WHERE <search condition>

--h3 7.9 <group by clause> (p320)
--/h3

/* 
Specify a grouped table derived by the application of the <group by clause> to the result of the
previously specified clause.
*/

<group by clause> ::= GROUP BY [ <set quantifier> ] <grouping element list>

<grouping element list> ::= <grouping element> [ { COMMA <grouping element> }... ]

<grouping element> ::=
		<ordinary grouping set>
	|	<rollup list>
	|	<cube list>
	|	<grouping sets specification>
	|	<empty grouping set>

<ordinary grouping set> ::=
		<grouping column reference>
	|	LPAR <grouping column reference list> RPAR

<grouping column reference> ::= <column reference> [ <collate clause> ]

<grouping column reference list> ::= <grouping column reference> [ { COMMA <grouping column reference> }... ]

<rollup list> ::= ROLLUP LPAR <ordinary grouping set list> RPAR

<ordinary grouping set list> ::= <ordinary grouping set> [ { COMMA <ordinary grouping set> }... ]

<cube list> ::= CUBE LPAR <ordinary grouping set list> RPAR

<grouping sets specification> ::= GROUPING SETS LPAR <grouping set list> RPAR

<grouping set list> ::= <grouping set> [ { COMMA <grouping set> }... ]

<grouping set> ::=
		<ordinary grouping set>
	|	<rollup list>
	|	<cube list>
	|	<grouping sets specification>
	|	<empty grouping set>

<empty grouping set> ::= LPAR RPAR

--h3 7.10 <having clause> (p329)
--/h3

/* 
Specify a grouped table derived by the elimination of groups that do not satisfy a <search condition>.
*/

<having clause> ::= HAVING <search condition>

--h3 7.11 <window clause> (p331)
--/h3

/* 
Specify one or more window definitions.
*/

<window clause> ::= WINDOW <window definition list>

<window definition list> ::= <window definition> [ { COMMA <window definition> }... ]

<window definition> ::= <new window name> AS <window specification>

<new window name> ::= <window name>

<window specification> ::= LPAR <window specification details> RPAR

<window specification details> ::=
		[ <existing window name> ] [ <window partition clause> ] [ <window order clause> ] [ <window frame clause> ]

<existing window name> ::= <window name>

<window partition clause> ::= PARTITION BY <window partition column reference list>

<window partition column reference list> ::= <window partition column reference> [ { COMMA <window partition column reference> }... ]

<window partition column reference> ::= <column reference> [ <collate clause> ]

<window order clause> ::= ORDER BY <sort specification list>

<window frame clause> ::= <window frame units> <window frame extent> [ <window frame exclusion> ]

<window frame units> ::= ROWS | RANGE

<window frame extent> ::= <window frame start> | <window frame between>

<window frame start> ::= UNBOUNDED PRECEDING | <window frame preceding> | CURRENT ROW

<window frame preceding> ::= <unsigned value specification> PRECEDING

<window frame between> ::= BETWEEN <window frame bound 1> AND <window frame bound 2>

<window frame bound 1> ::= <window frame bound>

<window frame bound 2> ::= <window frame bound>

<window frame bound> ::=
		<window frame start>
	|	UNBOUNDED FOLLOWING
	|	<window frame following>

<window frame following> ::= <unsigned value specification> FOLLOWING

<window frame exclusion> ::=
		EXCLUDE CURRENT ROW
	|	EXCLUDE GROUP
	|	EXCLUDE TIES
	|	EXCLUDE NO OTHERS

--h3 7.12 <query specification> (p341)
--/h3

/* 
Specify a table derived from the result of a <table expression>.
*/

<query specification> ::= SELECT [ <set quantifier> ] <select list> <table expression>

<select list> ::= ASTERISK | <select sublist> [ { COMMA <select sublist> }... ]

<select sublist> ::= <derived column> | <qualified asterisk>

<qualified asterisk> ::=
		<asterisked identifier chain> DOT ASTERISK
	|	<all fields reference>

<asterisked identifier chain> ::= <asterisked identifier> [ { DOT <asterisked identifier> }... ]

<asterisked identifier> ::= <identifier>

<derived column> ::= <value expression> [ <as clause> ]

<as clause> ::= [ AS ] <column name>

<all fields reference> ::= <value expression primary> DOT ASTERISK [ AS LPAR <all fields column name list> RPAR ]

<all fields column name list> ::= <column name list>

--h3 7.13 <query expression> (p350)
--/h3

/* 
Specify a table.
*/

<query expression> ::= [ <with clause> ] <query expression body>

<with clause> ::= WITH [ RECURSIVE ] <with list>

<with list> ::= <with list element> [ { COMMA <with list element> }... ]

<with list element> ::=
		<query name> [ LPAR <with column list> RPAR ]
		AS LPAR <query expression> RPAR [ <search or cycle clause> ]

<with column list> ::= <column name list>

<query expression body> ::= <non-join query expression> | <joined table>

<non-join query expression> ::=
		<non-join query term>
	|	<query expression body> UNION [ ALL | DISTINCT ] [ <corresponding spec> ] <query term>
	|	<query expression body> EXCEPT [ ALL | DISTINCT ] [ <corresponding spec> ] <query term>

<query term> ::= <non-join query term> | <joined table>

<non-join query term> ::=
		<non-join query primary>
	|	<query term> INTERSECT [ ALL | DISTINCT ] [ <corresponding spec> ] <query primary>

<query primary> ::= <non-join query primary> | <joined table>

<non-join query primary> ::= <simple table> | LPAR <non-join query expression> RPAR

<simple table> ::=
		<query specification>
	|	<table value constructor>
	|	<explicit table>

<explicit table> ::= TABLE <table or query name>

<corresponding spec> ::= CORRESPONDING [ BY LPAR <corresponding column list> RPAR ]

<corresponding column list> ::= <column name list>

--h3 7.14 <search or cycle clause> (p363)
--/h3

/* 
Specify the generation of ordering and cycle detection information in the result of recursive query
expressions.
*/

<search or cycle clause> ::=
		<search clause>
	|	<cycle clause>
	|	<search clause> <cycle clause>

<search clause> ::= SEARCH <recursive search order> SET <sequence column>

<recursive search order> ::=
		DEPTH FIRST BY <sort specification list>
	|	BREADTH FIRST BY <sort specification list>

<sequence column> ::= <column name>

<cycle clause> ::=
		CYCLE <cycle column list>
		SET <cycle mark column> TO <cycle mark value>
		DEFAULT <non-cycle mark value>
		USING <path column>

<cycle column list> ::= <cycle column> [ { COMMA <cycle column> }... ]

<cycle column> ::= <column name>

<cycle mark column> ::= <column name>

<path column> ::= <column name>

<cycle mark value> ::= <value expression>

<non-cycle mark value> ::= <value expression>

--h3 7.15 <subquery> (p368)
--/h3

/* 
Specify a scalar value, a row, or a table derived from a <query expression>.
*/

<scalar subquery> ::= <subquery>

<row subquery> ::= <subquery>

<table subquery> ::= <subquery>

<subquery> ::= LPAR <query expression> RPAR

--hr
--h2 8 Predicates
--/h2

--h3 8.1 <predicate> (p371)
--/h3

/* 
Specify a condition that can be evaluated to give a boolean value.
*/

<predicate> ::=
		<comparison predicate>
	|	<between predicate>
	|	<in predicate>
	|	<like predicate>
	|	<similar predicate>
	|	<null predicate>
	|	<quantified comparison predicate>
	|	<exists predicate>
	|	<unique predicate>
	|	<normalized predicate>
	|	<match predicate>
	|	<overlaps predicate>
	|	<distinct predicate>
	|	<member predicate>
	|	<submultiset predicate>
	|	<set predicate>
	|	<type predicate>

--h3 8.2 <comparison predicate> (p373)
--/h3

/* 
Specify a comparison of two row values.
*/

<comparison predicate> ::= <row value predicand> <comparison predicate part 2>

<comparison predicate part 2> ::= <comp op> <row value predicand>

<comp op> ::=
		EQ
	|	NE
	|	LT
	|	GT
	|	LE
	|	GE

--h3 8.3 <between predicate> (p380)
--/h3

/* 
Specify a range comparison.
*/

<between predicate> ::= <row value predicand> <between predicate part 2>

<between predicate part 2> ::= [ NOT ] BETWEEN [ ASYMMETRIC | SYMMETRIC ] <row value predicand> AND <row value predicand>

--h3 8.4 <in predicate> (p381)
--/h3

/* 
Specify a quantified comparison.
*/

<in predicate> ::= <row value predicand> <in predicate part 2> 

<in predicate part 2> ::= [ NOT ] IN <in predicate value>

<in predicate value> ::=
		<table subquery>
	|	LPAR <in value list> RPAR

<in value list> ::= <row value expression> [ { COMMA <row value expression> }... ]

--h3 8.5 <like predicate> (p383)
--/h3

/* 
Specify a pattern-match comparison.
*/

<like predicate> ::= <character like predicate> | <octet like predicate>

<character like predicate> ::= <row value predicand> <character like predicate part 2>

<character like predicate part 2> ::= [ NOT ] LIKE <character pattern> [ ESCAPE <escape character> ]

<character pattern> ::= <character value expression>

<escape character> ::= <character value expression>

<octet like predicate> ::= <row value predicand> <octet like predicate part 2>

<octet like predicate part 2> ::= [ NOT ] LIKE <octet pattern> [ ESCAPE <escape octet> ]

<octet pattern> ::= <blob value expression>

<escape octet> ::= <blob value expression>

--h3 8.6 <similar predicate> (p389)
--/h3

/* 
Specify a character string similarity by means of a regular expression.
*/

<similar predicate> ::= <row value predicand> <similar predicate part 2>

<similar predicate part 2> ::= [ NOT ] SIMILAR TO <similar pattern> [ ESCAPE <escape character> ]

<similar pattern> ::= <character value expression>

<regular expression> ::=
		<regular term>
	|	<regular expression> BAR_VER <regular term>

<regular term> ::=
		<regular factor>
	|	<regular term> <regular factor>

<regular factor> ::=
		<regular primary>
	|	<regular primary> ASTERISK
	|	<regular primary> PLUS
	|	<regular primary> QUESTION
	|	<regular primary> <repeat factor>

<repeat factor> ::= LLLAVE <low value> [ <upper limit> ] RLLAVE

<upper limit> ::= COMMA [ <high value> ]

<low value> ::= unsigned_integer

<high value> ::= unsigned_integer

<regular primary> ::=
		<character specifier>
	|	PERCENT
	|	<regular character set>
	|	LPAR <regular expression> RPAR

<character specifier> ::= <non-escaped character> | <escaped character>

<non-escaped character> ::= !! See the Syntax Rules.

<escaped character> ::= !! See the Syntax Rules.

<regular character set> ::=
		UNDERSCORE
	|	LBRA <character enumeration>... RBRA
	|	LBRA CIRCUMFLEX <character enumeration>... RBRA
	|	LBRA <character enumeration include>...  CIRCUMFLEX <character enumeration exclude>... RBRA

<character enumeration include> ::= <character enumeration>

<character enumeration exclude> ::= <character enumeration>

<character enumeration> ::=
		<character specifier>
	|	<character specifier> MINUS <character specifier>
	|	LBRA COLON <regular character set identifier> COLON RBRA

<regular character set identifier> ::= <identifier>

--h3 8.7 <null predicate> (p395)
--/h3

/* 
Specify a test for a null value.
*/

<null predicate> ::= <row value predicand> <null predicate part 2>

<null predicate part 2> ::= IS [ NOT ] NULL 

--h3 8.8 <quantified comparison predicate> (p397)
--/h3

/* 
Specify a quantified comparison.
*/

<quantified comparison predicate> ::= <row value predicand> <quantified comparison predicate part 2>

<quantified comparison predicate part 2> ::= <comp op> <quantifier> <table subquery>

<quantifier> ::= <all> | <some>

<all> ::= ALL

<some> ::= SOME | ANY

--h3 8.9 <exists predicate> (p399)
--/h3

/* 
Specify a test for a non-empty set.
*/

<exists predicate> ::= EXISTS <table subquery>

--h3 8.10 <unique predicate> (p400)
--/h3

/*
Specify a test for the absence of duplicate rows
*/

<unique predicate> ::= UNIQUE <table subquery>

--h3 8.11 <normalized predicate> (p401)
--/h3

/* 
Determine whether a character string value is normalized.
*/

<normalized predicate> ::= <string value expression> IS [ NOT ] NORMALIZED

--h3 8.12 <match predicate> (p402)
--/h3

/* 
Specify a test for matching rows.
*/

<match predicate> ::= <row value predicand> <match predicate part 2>

<match predicate part 2> ::= MATCH [ UNIQUE ] [ SIMPLE | PARTIAL | FULL ] <table subquery>

--h3 8.13 <overlaps predicate> (p405)
--/h3

/* 
Specify a test for an overlap between two datetime periods.
*/

<overlaps predicate> ::= <overlaps predicate part 1> <overlaps predicate part 2>

<overlaps predicate part 1> ::= <row value predicand 1>

<overlaps predicate part 2> ::= OVERLAPS <row value predicand 2>

<row value predicand 1> ::= <row value predicand>

<row value predicand 2> ::= <row value predicand>

--h3 8.14 <distinct predicate> (p407)
--/h3

/* 
Specify a test of whether two row values are distinct
*/

<distinct predicate> ::= <row value predicand 3> <distinct predicate part 2>

<distinct predicate part 2> ::= IS DISTINCT FROM <row value predicand 4>

<row value predicand 3> ::= <row value predicand>

<row value predicand 4> ::= <row value predicand>

--h3 8.15 <member predicate> (p409)
--/h3

/* 
Specify a test of whether a value is a member of a multiset.
*/

<member predicate> ::= <row value predicand> <member predicate part 2>

<member predicate part 2> ::= [ NOT ] MEMBER [ OF ] <multiset value expression>

--h3 8.16 <submultiset predicate> (p411)
--/h3

/* 
Specify a test of whether a multiset is a submultiset of another multiset.
*/

<submultiset predicate> ::= <row value predicand> <submultiset predicate part 2>

<submultiset predicate part 2> ::= [ NOT ] SUBMULTISET [ OF ] <multiset value expression>

--h3 8.17 <set predicate> (p413)
--/h3

/* 
Specify a test of whether a multiset is a set (that is, does not contain any duplicates).
*/

<set predicate> ::= <row value predicand> <set predicate part 2>

<set predicate part 2> ::= IS [ NOT ] A SET

--h3 8.18 <type predicate> (p414)
--/h3

/* 
Specify a type test.
*/

<type predicate> ::= <row value predicand> <type predicate part 2>

<type predicate part 2> ::= IS [ NOT ] OF LPAR <type list> RPAR

<type list> ::= <user-defined type specification> [ { COMMA <user-defined type specification> }... ]

<user-defined type specification> ::=
		<inclusive user-defined type specification>
	|	<exclusive user-defined type specification>

<inclusive user-defined type specification> ::= <path-resolved user-defined type name>

<exclusive user-defined type specification> ::= ONLY <path-resolved user-defined type name>

--h3 8.19 <search condition> (p416)
--/h3

/* 
Specify a condition that is True , False , or Unknown , depending on the value of a <boolean value
expression>.
*/

<search condition> ::= <boolean value expression>

--hr
--h2 9 Additional common rules
--/h2

--h3 9.1 Retrieval assignment (p417)
--/h3

--h3 9.2 Store assignment (p422)
--/h3

--h3 9.3 Data types of results of aggregations (p427)
--/h3

--h3 9.4 Subject routine determination (p430)
--/h3

--h3 9.5 Type precedence list determination (p431)
--/h3

--h3 9.6 Host parameter mode determination (p434)
--/h3

--h3 9.7 Type name determination (p436)
--/h3

--h3 9.8 Determination of identical values (p438)
--/h3

--h3 9.9 Equality operations (p440)
--/h3

--h3 9.10 Grouping operations (p443)
--/h3

--h3 9.11 Multiset element grouping operations (p445)
--/h3

--h3 9.12 Ordering operations (p447)
--/h3

--h3 9.13 Collation determination (p449)
--/h3

--h3 9.14 Execution of array-returning functions (p450)
--/h3

--h3 9.15 Execution of multiset-returning functions (p453)
--/h3

--h3 9.16 Data type identity (p454)
--/h3

--h3 9.17 Determination of a from-sql function (p456)
--/h3

--h3 9.18 Determination of a from-sql function for an overriding method (p457)
--/h3

--h3 9.19 Determination of a to-sql function (p458)
--/h3

--h3 9.20 Determination of a to-sql function for an overriding method (p459)
--/h3

--h3 9.21 Generation of the next value of a sequence generator (p460)
--/h3

--h3 9.22 Creation of a sequence generator (p461)
--/h3

--h3 9.23 Altering a sequence generator (p463)
--/h3

--hr
--h2 10 Additional common elements
--/h2

--h3 10.1 <interval qualifier> (p465)
--/h3

/* 
Specify the precision of an interval data type.
*/

<interval qualifier> ::=
		<start field> TO <end field>
	|	<single datetime field>

<start field> ::= <non-second primary datetime field> [ LPAR <interval leading field precision> RPAR ]

<end field> ::=
		<non-second primary datetime field>
	|	SECOND [ LPAR <interval fractional seconds precision> RPAR ]

<single datetime field> ::=
		<non-second primary datetime field> [ LPAR <interval leading field precision> RPAR ]
	|	SECOND [ LPAR <interval leading field precision> [ COMMA <interval fractional seconds precision> ] RPAR ]

<primary datetime field> ::=
		<non-second primary datetime field>
	|	SECOND

<non-second primary datetime field> ::= YEAR | MONTH | DAY | HOUR | MINUTE

<interval fractional seconds precision> ::= unsigned_integer

<interval leading field precision> ::= unsigned_integer

--h3 10.2 <language clause> (p469)
--/h3

/* 
Specify a standard programming language.
*/

<language clause> ::= LANGUAGE <language name>

<language name> ::= ADA | C | COBOL | FORTRAN | MUMPS | PASCAL | PLI | SQL

/*
Table 14 -- Standard programming languages
*/

--## <table border=1>
--## <tr> <th> Language keyword </th> <th> Relevant standard </th> </tr>
--## <tr><td>ADA</td><td>ISO/IEC 8652</td></tr>
--## <tr><td>C</td><td>ISO/IEC 9899</td></tr>
--## <tr><td>COBOL</td><td>ISO 1989</td></tr>
--## <tr><td>FORTRAN</td><td>ISO 1539</td></tr>
--## <tr><td>MUMPS</td><td>ISO/IEC 11756</td></tr>
--## <tr><td>PASCAL</td><td>ISO/IEC 7185 and ISO/IEC 10206</td></tr>
--## <tr><td>PLI</td><td>ISO 6160</td></tr>
--## <tr><td>SQL</td><td>ISO/IEC 9075</td></tr>
--## </table>

--h3 10.3 <path specification> (p471)
--/h3

/* 
Specify an order for searching for an SQL-invoked routine.
*/

<path specification> ::= PATH <schema name list>

<schema name list> ::= <schema name> [ { COMMA <schema name> }... ]

--h3 10.4 <routine invocation> (p472)
--/h3

/* 
Invoke an SQL-invoked routine.
*/

<routine invocation> ::= <routine name> <SQL argument list>

<routine name> ::= [ <schema name> DOT ] <qualified identifier>

<SQL argument list> ::= LPAR [ <SQL argument> [ { COMMA <SQL argument> }... ] ] RPAR

<SQL argument> ::=
		<value expression>
	|	<generalized expression>
	|	<target specification>

<generalized expression> ::= <value expression> AS <path-resolved user-defined type name>

--h3 10.5 <character set specification> (p495)
--/h3

/* 
Identify a character set.
*/

<character set specification> ::=
		<standard character set name>
	|	<implementation-defined character set name>
	|	<user-defined character set name>

<standard character set name> ::= <character set name>

<implementation-defined character set name> ::= <character set name>

<user-defined character set name> ::= <character set name>

--h3 10.6 <specific routine designator> (p497)
--/h3

/* 
Specify an SQL-invoked routine.
*/

<specific routine designator> ::=
		SPECIFIC <routine type> <specific name>
			|	<routine type> <member name>
		[ FOR <schema-resolved user-defined type name> ]

<routine type> ::=
		ROUTINE
	|	FUNCTION
	|	PROCEDURE
	|	[ INSTANCE | STATIC | CONSTRUCTOR ] METHOD

<member name> ::= <member name alternatives> [ <data type list> ]

<member name alternatives> ::= <schema qualified routine name> | <method name>

<data type list> ::= LPAR [ <data type> [ { COMMA <data type> }... ] ] RPAR

--h3 10.7 <collate clause> (p500)
--/h3

/* 
Specify a default collating sequence.
*/

<collate clause> ::= COLLATE <collation name>

--h3 10.8 <constraint name definition> and <constraint characteristics> (p501)
--/h3

/* 
Specify the name of a constraint and its characteristics.
*/

<constraint name definition> ::= CONSTRAINT constraint_name

<constraint characteristics> ::=
		<constraint check time> [ [ NOT ] DEFERRABLE ]
	|	[ NOT ] DEFERRABLE [ <constraint check time> ]

<constraint check time> ::= INITIALLY DEFERRED | INITIALLY IMMEDIATE

--h3 10.9 <aggregate function> (p503)
--/h3

/* 
Specify a value computed from a collection of rows.
*/

<aggregate function> ::=
		COUNT LPAR ASTERISK RPAR [ <filter clause> ]
	|	<general set function> [ <filter clause> ]
	|	<binary set function> [ <filter clause> ]
	|	<ordered set function> [ <filter clause> ]

<general set function> ::= <set function type> LPAR [ <set quantifier> ] <value expression> RPAR

<set function type> ::= <computational operation>

<computational operation> ::=
		AVG | MAX | MIN | SUM
	|	EVERY | ANY | SOME
	|	COUNT
	|	STDDEV_POP | STDDEV_SAMP | VAR_SAMP | VAR_POP
	|	COLLECT | FUSION | INTERSECTION

<set quantifier> ::= DISTINCT | ALL

<filter clause> ::= FILTER LPAR WHERE <search condition> RPAR

<binary set function> ::= <binary set function type> LPAR <dependent variable expression> COMMA <independent variable expression> RPAR

<binary set function type> ::=
		COVAR_POP | COVAR_SAMP | CORR | REGR_SLOPE
	|	REGR_INTERCEPT | REGR_COUNT | REGR_R2 | REGR_AVGX | REGR_AVGY
	|	REGR_SXX | REGR_SYY | REGR_SXY

<dependent variable expression> ::= <numeric value expression>

<independent variable expression> ::= <numeric value expression>

<ordered set function> ::= <hypothetical set function> | <inverse distribution function>

<hypothetical set function> ::= <rank function type> LPAR <hypothetical set function value expression list> RPAR <within group specification>

<within group specification> ::= WITHIN GROUP LPAR ORDER BY <sort specification list> RPAR

<hypothetical set function value expression list> ::= <value expression> [ { COMMA <value expression> }... ]

<inverse distribution function> ::= <inverse distribution function type> LPAR <inverse distribution function argument> RPAR <within group specification>

<inverse distribution function argument> ::= <numeric value expression>

<inverse distribution function type> ::= PERCENTILE_CONT | PERCENTILE_DISC

--h3 10.10 <sort specification list> (p515)
--/h3

/* 
Specify a sort order.
*/

<sort specification list> ::= <sort specification> [ { COMMA <sort specification> }... ]

<sort specification> ::= <sort key> [ <ordering specification> ] [ <null ordering> ]

<sort key> ::= <value expression>

<ordering specification> ::= ASC | DESC

<null ordering> ::= NULLS FIRST | NULLS LAST

--hr
--h2 11 Schema definition and manipulation
--/h2

--h3 11.1 <schema definition> (p517)
--/h3

/* 
Define a schema.
*/

<schema definition> ::= CREATE SCHEMA <schema name clause> [ <schema character set or path> ] [ <schema element>... ]

<schema character set or path> ::=
		<schema character set specification>
	|	<schema path specification>
	|	<schema character set specification> <schema path specification>
	|	<schema path specification> <schema character set specification>

<schema name clause> ::=
		<schema name>
	|	AUTHORIZATION <schema authorization identifier>
	|	<schema name> AUTHORIZATION <schema authorization identifier>

<schema authorization identifier> ::= <authorization identifier>

<schema character set specification> ::= DEFAULT CHARACTER SET <character set specification>

<schema path specification> ::= <path specification>

<schema element> ::=
		<table definition>
	|	<view definition>
	|	<domain definition>
	|	<character set definition>
	|	<collation definition>
	|	<transliteration definition>
	|	<assertion definition>
	|	<trigger definition>
	|	<user-defined type definition>
	|	<user-defined cast definition>
	|	<user-defined ordering definition>
	|	<transform definition>
	|	<schema routine>
	|	<sequence generator definition>
	|	<grant statement>
	|	<role definition>

--h3 11.2 <drop schema statement> (p520)
--/h3

/* 
Destroy a schema.
*/

<drop schema statement> ::= DROP SCHEMA <schema name> <drop behavior>

<drop behavior> ::= CASCADE | RESTRICT

--h3 11.3 <table definition> (p523)
--/h3

/* 
Define a persistent base table, a created local temporary table, or a global temporary table.
*/

<table definition> ::=
		CREATE [ <table scope> ] TABLE <table name> <table contents source>
		[ ON COMMIT <table commit action> ROWS ]

<table contents source> ::=
		<table element list>
	|	OF <path-resolved user-defined type name> [ <subtable clause> ] [ <table element list> ]
	|	<as subquery clause>

<table scope> ::= <global or local> TEMPORARY

<global or local> ::= GLOBAL | LOCAL

<table commit action> ::= PRESERVE | DELETE

<table element list> ::= LPAR <table element> [ { COMMA <table element> }... ] RPAR

<table element> ::=
		<column definition>
	|	<table constraint definition>
	|	<like clause>
	|	<self-referencing column specification>
	|	<column options>

<self-referencing column specification> ::= REF IS <self-referencing column name> <reference generation>

<reference generation> ::= SYSTEM GENERATED | USER GENERATED | DERIVED

<self-referencing column name> ::= <column name>

<column options> ::= <column name> WITH OPTIONS <column option list>

<column option list> ::= [ <scope clause> ] [ <default clause> ] [ <column constraint definition>... ]

<subtable clause> ::= UNDER <supertable clause>

<supertable clause> ::= <supertable name>

<supertable name> ::= <table name>

<like clause> ::= LIKE <table name> [ <like options> ]

<like options> ::= <identity option> | <column default option>

<identity option> ::= INCLUDING IDENTITY | EXCLUDING IDENTITY

<column default option> ::= INCLUDING DEFAULTS | EXCLUDING DEFAULTS

<as subquery clause> ::= [ LPAR <column name list> RPAR ] AS <subquery> <with or without data>

<with or without data> ::= WITH NO DATA | WITH DATA

--h3 11.4 <column definition> (p534)
--/h3

/* 
Define a column of a base table.
*/

<column definition> ::=
		<column name> [ <data type> | <domain name> ] [ <reference scope check> ]
		[ <default clause> | <identity column specification> | <generation clause> ]
		[ <column constraint definition>... ] [ <collate clause> ]

<column constraint definition> ::= [ <constraint name definition> ] <column constraint> [ <constraint characteristics> ]

<column constraint> ::=
		NOT NULL
	|	<unique specification>
	|	<references specification>
	|	<check constraint definition>

<reference scope check> ::= REFERENCES ARE [ NOT ] CHECKED [ ON DELETE <reference scope check action> ]

<reference scope check action> ::= <referential action>

<identity column specification> ::=
		GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY
		[ LPAR <common sequence generator options> RPAR ]

<generation clause> ::= <generation rule> AS <generation expression>

<generation rule> ::= GENERATED ALWAYS

<generation expression> ::= LPAR <value expression> RPAR

--h3 11.5 <default clause> (p539)
--/h3

/* 
Specify the default for a column, domain, or attribute.
*/

<default clause> ::= DEFAULT <default option>

<default option> ::=
		<literal>
	|	<datetime value function>
	|	USER
	|	CURRENT_USER
	|	CURRENT_ROLE
	|	SESSION_USER
	|	SYSTEM_USER
	|	CURRENT_PATH
	|	<implicitly typed value specification>

--h3 11.6 <table constraint definition> (p543)
--/h3

/* 
Specify an integrity constraint.
*/

<table constraint definition> ::= [ <constraint name definition> ] <table constraint> [ <constraint characteristics> ]

<table constraint> ::=
		<unique constraint definition>
	|	<referential constraint definition>
	|	<check constraint definition>

--h3 11.7 <unique constraint definition> (p545)
--/h3

/* 
Specify a uniqueness constraint for a table.
*/

<unique constraint definition> ::=
		<unique specification> LPAR <unique column list> RPAR
	|	UNIQUE ( VALUE )

<unique specification> ::= UNIQUE | PRIMARY KEY

<unique column list> ::= <column name list>

--h3 11.8 <referential constraint definition> (p547)
--/h3

/* 
Specify a referential constraint.
*/

<referential constraint definition> ::= FOREIGN KEY LPAR <referencing columns> RPAR <references specification>

<references specification> ::= REFERENCES <referenced table and columns> [ MATCH <match type> ] [ <referential triggered action> ]

<match type> ::= FULL | PARTIAL | SIMPLE

<referencing columns> ::= <reference column list>

<referenced table and columns> ::= <table name> [ LPAR <reference column list> RPAR ]

<reference column list> ::= <column name list>

<referential triggered action> ::= <update rule> [ <delete rule> ] | <delete rule> [ <update rule> ]

<update rule> ::= ON UPDATE <referential action>

<delete rule> ::= ON DELETE <referential action>

<referential action> ::= CASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION

--h3 11.9 <check constraint definition> (p567)
--/h3

/* 
Specify a condition for the SQL-data.
*/

<check constraint definition> ::= CHECK LPAR <search condition> RPAR

--h3 11.10 <alter table statement> (p569)
--/h3

/* 
Change the definition of a table.
*/

<alter table statement> ::= ALTER TABLE <table name> <alter table action>

<alter table action> ::=
		<add column definition>
	|	<alter column definition>
	|	<drop column definition>
	|	<add table constraint definition>
	|	<drop table constraint definition>

--h3 11.11 <add column definition> (p570)
--/h3

/* 
Add a column to a table.
*/

<add column definition> ::= ADD [ COLUMN ] <column definition>

--h3 11.12 <alter column definition> (p572)
--/h3

/* 
Change a column and its definition.
*/

<alter column definition> ::= ALTER [ COLUMN ] <column name> <alter column action>

<alter column action> ::=
		<set column default clause>
	|	<drop column default clause>
	|	<add column scope clause>
	|	<drop column scope clause>
	|	<alter identity column specification>

--h3 11.13 <set column default clause> (p573)
--/h3

/* 
Set the default clause for a column.
*/

<set column default clause> ::= SET <default clause>

--h3 11.14 <drop column default clause> (p574)
--/h3

/* 
Drop the default clause from a column.
*/

<drop column default clause> ::= DROP DEFAULT

--h3 11.15 <add column scope clause> (p575)
--/h3

/* 
Add a non-empty scope for an existing column of data type REF in a base table.
*/

<add column scope clause> ::= ADD <scope clause>

--h3 11.16 <drop column scope clause> (p576)
--/h3

/* 
Drop the scope from an existing column of data type REF in a base table.
*/

<drop column scope clause> ::= DROP SCOPE <drop behavior>

--h3 11.17 <alter identity column specification> (p578)
--/h3

/* 
Change the options specified for an identity column.
*/

<alter identity column specification> ::= <alter identity column option>...

<alter identity column option> ::=
		<alter sequence generator restart option>
	|	SET <basic sequence generator option>

--h3 11.18 <drop column definition> (p579)
--/h3

/* 
Destroy a column of a base table.
*/

<drop column definition> ::= DROP [ COLUMN ] <column name> <drop behavior>

--h3 11.19 <add table constraint definition> (p581)
--/h3

/* 
Add a constraint to a table.
*/

<add table constraint definition> ::= ADD <table constraint definition>

--h3 11.20 <drop table constraint definition> (p582)
--/h3

/* 
Destroy a constraint on a table.
*/

<drop table constraint definition> ::= DROP CONSTRAINT constraint_name <drop behavior>

--h3 11.21 <drop table statement> (p585)
--/h3

/* 
Destroy a table.
*/

<drop table statement> ::= DROP TABLE <table name> <drop behavior>

--h3 11.22 <view definition> (p588)
--/h3

/* 
Define a viewed table.
*/

<view definition> ::=
		CREATE [ RECURSIVE ] VIEW <table name> <view specification> AS <query expression>
		[ WITH [ <levels clause> ] CHECK OPTION ]

<view specification> ::= <regular view specification> | <referenceable view specification>

<regular view specification> ::= [ LPAR <view column list> RPAR ]

<referenceable view specification> ::= OF <path-resolved user-defined type name> [ <subview clause> ] [ <view element list> ]

<subview clause> ::= UNDER <table name>

<view element list> ::= LPAR <view element> [ { COMMA <view element> }... ] RPAR

<view element> ::= <self-referencing column specification> | <view column option>

<view column option> ::= <column name> WITH OPTIONS <scope clause>

<levels clause> ::= CASCADED | LOCAL

<view column list> ::= <column name list>

--h3 11.23 <drop view statement> (p598)
--/h3

/* 
Destroy a view.
*/

<drop view statement> ::= DROP VIEW <table name> <drop behavior>

--h3 11.24 <domain definition> (p601)
--/h3

/* 
Define a domain.
*/

<domain definition> ::=
		CREATE DOMAIN <domain name> [ AS ] <data type>
		[ <default clause> ] [ <domain constraint>... ] [ <collate clause> ]

<domain constraint> ::= [ <constraint name definition> ] <check constraint definition> [ <constraint characteristics> ]

--h3 11.25 <alter domain statement> (p603)
--/h3

/* 
Change a domain and its definition.
*/

<alter domain statement> ::= ALTER DOMAIN <domain name> <alter domain action>

<alter domain action> ::=
		<set domain default clause>
	|	<drop domain default clause>
	|	<add domain constraint definition>
	|	<drop domain constraint definition>

--h3 11.26 <set domain default clause> (p604)
--/h3

/* 
Set the default value in a domain.
*/

<set domain default clause> ::= SET <default clause>

--h3 11.27 <drop domain default clause> (p605)
--/h3

/* 
Remove the default clause of a domain.
*/

<drop domain default clause> ::= DROP DEFAULT

--h3 11.28 <add domain constraint definition> (p606)
--/h3

/* 
Add a constraint to a domain.
*/

<add domain constraint definition> ::= ADD <domain constraint>

--h3 11.29 <drop domain constraint definition> (p607)
--/h3

/* 
Destroy a constraint on a domain.
*/

<drop domain constraint definition> ::= DROP CONSTRAINT constraint_name

--h3 11.30 <drop domain statement> (p608)
--/h3

/* 
Destroy a domain.
*/

<drop domain statement> ::= DROP DOMAIN <domain name> <drop behavior>

--h3 11.31 <character set definition> (p610)
--/h3

/* 
Define a character set.
*/

<character set definition> ::=
		CREATE CHARACTER SET <character set name> [ AS ] <character set source> [ <collate clause> ]

<character set source> ::= GET <character set specification>

--h3 11.32 <drop character set statement> (p612)
--/h3

/* 
Destroy a character set.
*/

<drop character set statement> ::= DROP CHARACTER SET <character set name>

--h3 11.33 <collation definition> (p614)
--/h3

/* 
Define a collating sequence.
*/

<collation definition> ::=
		CREATE COLLATION <collation name> FOR <character set specification>
		FROM <existing collation name> [ <pad characteristic> ]

<existing collation name> ::= <collation name>

<pad characteristic> ::= NO PAD | PAD SPACE

--h3 11.34 <drop collation statement> (p616)
--/h3

/* 
Destroy a collating sequence.
*/

<drop collation statement> ::= DROP COLLATION <collation name> <drop behavior>

--h3 11.35 <transliteration definition> (p618)
--/h3

/* 
Define a character transliteration.
*/

<transliteration definition> ::=
		CREATE TRANSLATION <transliteration name> FOR <source character set specification>
		TO <target character set specification> FROM <transliteration source>

<source character set specification> ::= <character set specification>

<target character set specification> ::= <character set specification>

<transliteration source> ::= <existing transliteration name> | <transliteration routine>

<existing transliteration name> ::= <transliteration name>

<transliteration routine> ::= <specific routine designator>

--h3 11.36 <drop transliteration statement> (p621)
--/h3

/* 
Destroy a character transliteration.
*/

<drop transliteration statement> ::= DROP TRANSLATION <transliteration name>

--h3 11.37 <assertion definition> (p623)
--/h3

/* 
Specify an integrity constraint.
*/

<assertion definition> ::=
		CREATE ASSERTION constraint_name CHECK LPAR <search condition> RPAR [ <constraint characteristics> ]

--h3 11.38 <drop assertion statement> (p625)
--/h3

/* 
Destroy an assertion.
*/

<drop assertion statement> ::= DROP ASSERTION constraint_name

--h3 11.39 <trigger definition> (p627)
--/h3

/* 
Define triggered SQL-statements.
*/

<trigger definition> ::=
		CREATE TRIGGER <trigger name> <trigger action time> <trigger event>
		ON <table name> [ REFERENCING <old or new values alias list> ]
		<triggered action>

<trigger action time> ::= BEFORE | AFTER

<trigger event> ::= INSERT | DELETE | UPDATE [ OF <trigger column list> ]

<trigger column list> ::= <column name list>

<triggered action> ::=
		[ FOR EACH { ROW | STATEMENT } ]
		[ WHEN LPAR <search condition> RPAR ]
		<triggered SQL statement>

<triggered SQL statement> ::=
		<SQL procedure statement>
	|	BEGIN ATOMIC { <SQL procedure statement> SEMICOLON }...  END

<old or new values alias list> ::= <old or new values alias>...

<old or new values alias> ::=
		OLD [ ROW ] [ AS ] <old values correlation name>
	|	NEW [ ROW ] [ AS ] <new values correlation name>
	|	OLD TABLE [ AS ] <old values table alias>
	|	NEW TABLE [ AS ] <new values table alias>

<old values table alias> ::= <identifier>

<new values table alias> ::= <identifier>

<old values correlation name> ::= <correlation name>

<new values correlation name> ::= <correlation name>

--h3 11.40 <drop trigger statement> (p631)
--/h3

/* 
Destroy a trigger.
*/

<drop trigger statement> ::= DROP TRIGGER <trigger name>

--h3 11.41 <user-defined type definition> (p632)
--/h3

/* 
Define a user-defined type.
*/

<user-defined type definition> ::= CREATE TYPE <user-defined type body>

<user-defined type body> ::=
		<schema-resolved user-defined type name> [ <subtype clause> ]
		[ AS <representation> ] [ <user-defined type option list> ] [ <method specification list> ]

<user-defined type option list> ::= <user-defined type option> [ <user-defined type option>... ]

<user-defined type option> ::=
		<instantiable clause>
	|	<finality>
	|	<reference type specification>
	|	<ref cast option>
	|	<cast option>

<subtype clause> ::=
		UNDER <supertype name>

<supertype name> ::=
		<path-resolved user-defined type name>

<representation> ::= <predefined type> | <member list>

<member list> ::= LPAR <member> [ { COMMA <member> }... ] RPAR

<member> ::= <attribute definition>

<instantiable clause> ::= INSTANTIABLE | NOT INSTANTIABLE

<finality> ::= FINAL | NOT FINAL

<reference type specification> ::=
		<user-defined representation>
	|	<derived representation>
	|	<system-generated representation>

<user-defined representation> ::= REF USING <predefined type>

<derived representation> ::= REF FROM <list of attributes>

<system-generated representation> ::= REF IS SYSTEM GENERATED

<ref cast option> ::= [ <cast to ref> ] [ <cast to type> ]

<cast to ref> ::= CAST LPAR SOURCE AS REF RPAR WITH <cast to ref identifier>

<cast to ref identifier> ::= <identifier>

<cast to type> ::= CAST LPAR REF AS SOURCE RPAR WITH <cast to type identifier>

<cast to type identifier> ::= <identifier>

<list of attributes> ::= LPAR <attribute name> [ { COMMA <attribute name> }...] RPAR

<cast option> ::= [ <cast to distinct> ] [ <cast to source> ]

<cast to distinct> ::=
		CAST LPAR SOURCE AS DISTINCT RPAR
		WITH <cast to distinct identifier>

<cast to distinct identifier> ::= <identifier>

<cast to source> ::=
		CAST LPAR DISTINCT AS SOURCE RPAR
		WITH <cast to source identifier>

<cast to source identifier> ::= <identifier>

<method specification list> ::= <method specification> [ { COMMA <method specification> }... ]

<method specification> ::= <original method specification> | <overriding method specification>

<original method specification> ::=
		<partial method specification> [ SELF AS RESULT ] [ SELF AS LOCATOR ] [ <method characteristics> ]

<overriding method specification> ::= OVERRIDING <partial method specification>

<partial method specification> ::=
		[ INSTANCE | STATIC | CONSTRUCTOR ] METHOD <method name> <SQL parameter declaration list>
		<returns clause> [ SPECIFIC <specific method name> ]

<specific method name> ::= [ <schema name> DOT ]<qualified identifier>

<method characteristics> ::= <method characteristic>...

<method characteristic> ::=
		<language clause>
	|	<parameter style clause>
	|	<deterministic characteristic>
	|	<SQL-data access indication>
	|	<null-call clause>

--h3 11.42 <attribute definition> (p648)
--/h3

/* 
Define an attribute of a structured type.
*/

<attribute definition> ::=
		<attribute name> <data type> [ <reference scope check> ] [ <attribute default> ] [ <collate clause> ]

<attribute default> ::= <default clause>

--h3 11.43 <alter type statement> (p650)
--/h3

/* 
Change the definition of a user-defined type.
*/

<alter type statement> ::=
ALTER TYPE <schema-resolved user-defined type name> <alter type action>

<alter type action> ::=
		<add attribute definition>
	|	<drop attribute definition>
	|	<add original method specification>
	|	<add overriding method specification>
	|	<drop method specification>

--h3 11.44 <add attribute definition> (p651)
--/h3

/* 
Add an attribute to a user-defined type.
*/

<add attribute definition> ::= ADD ATTRIBUTE <attribute definition>

--h3 11.45 <drop attribute definition> (p653)
--/h3

/* 
Destroy an attribute of a user-defined type.
*/

<drop attribute definition> ::= DROP ATTRIBUTE <attribute name> RESTRICT

--h3 11.46 <add original method specification> (p655)
--/h3

/* 
Add an original method specification to a user-defined type.
*/

<add original method specification> ::= ADD <original method specification>

--h3 11.47 <add overriding method specification> (p661)
--/h3

/* 
Add an overriding method specification to a user-defined type.
*/

<add overriding method specification> ::= ADD <overriding method specification>

--h3 11.48 <drop method specification> (p666)
--/h3

/* 
Remove a method specification from a user-defined type.
*/

<drop method specification> ::= DROP <specific method specification designator> RESTRICT

<specific method specification designator> ::= [ INSTANCE | STATIC | CONSTRUCTOR ] METHOD <method name> <data type list>

--h3 11.49 <drop data type statement> (p670)
--/h3

/* 
Destroy a user-defined type.
*/

<drop data type statement> ::= DROP TYPE <schema-resolved user-defined type name> <drop behavior>

--h3 11.50 <SQL-invoked routine> (p673)
--/h3

/* 
Define an SQL-invoked routine.
*/

<SQL-invoked routine> ::= <schema routine>

<schema routine> ::= <schema procedure> | <schema function>

<schema procedure> ::= CREATE <SQL-invoked procedure>

<schema function> ::= CREATE <SQL-invoked function>

<SQL-invoked procedure> ::=
		PROCEDURE <schema qualified routine name> <SQL parameter declaration list> <routine characteristics> <routine body>

<SQL-invoked function> ::=
		{ <function specification> | <method specification designator> } <routine body>

<SQL parameter declaration list> ::=
		LPAR [ <SQL parameter declaration> [ { COMMA <SQL parameter declaration> }... ] ] RPAR

<SQL parameter declaration> ::= [ <parameter mode> ] [ <SQL parameter name> ] <parameter type> [ RESULT ]

<parameter mode> ::= IN | OUT | INOUT

<parameter type> ::= <data type> [ <locator indication> ]

<locator indication> ::= AS LOCATOR

<function specification> ::=
		FUNCTION <schema qualified routine name>
		<SQL parameter declaration list> <returns clause> <routine characteristics> [ <dispatch clause> ]

<method specification designator> ::=
		SPECIFIC METHOD <specific method name>
	|	[ INSTANCE | STATIC | CONSTRUCTOR ] METHOD <method name> <SQL parameter declaration list>
		[ <returns clause> ] FOR <schema-resolved user-defined type name>

<routine characteristics> ::= [ <routine characteristic>... ]

<routine characteristic> ::=
		<language clause>
	|	<parameter style clause>
	|	SPECIFIC <specific name>
	|	<deterministic characteristic>
	|	<SQL-data access indication>
	|	<null-call clause>
	|	<dynamic result sets characteristic>
	|	<savepoint level indication>

<savepoint level indication> ::= NEW SAVEPOINT LEVEL | OLD SAVEPOINT LEVEL

<dynamic result sets characteristic> ::= DYNAMIC RESULT SETS <maximum dynamic result sets>

<parameter style clause> ::= PARAMETER STYLE <parameter style>

<dispatch clause> ::= STATIC DISPATCH

<returns clause> ::= RETURNS <returns type>

<returns type> ::=
		<returns data type> [ <result cast> ]
	|	<returns table type>

<returns table type> ::= TABLE <table function column list>

<table function column list> ::=
		LPAR
		<table function column list element> [ { COMMA <table function column list element> }... ]
		RPAR

<table function column list element> ::= <column name> <data type>

<result cast> ::= CAST FROM <result cast from type>

<result cast from type> ::= <data type> [ <locator indication> ]

<returns data type> ::= <data type> [ <locator indication> ]

<routine body> ::=
		<SQL routine spec>
	|	<external body reference>

<SQL routine spec> ::= [ <rights clause> ] <SQL routine body>

<rights clause> ::= SQL SECURITY INVOKER | SQL SECURITY DEFINER

<SQL routine body> ::= <SQL procedure statement>

<external body reference> ::=
		EXTERNAL [ NAME <external routine name> ] [ <parameter style clause> ]
		[ <transform group specification> ] [ <external security clause> ]

<external security clause> ::=
		EXTERNAL SECURITY DEFINER
	|	EXTERNAL SECURITY INVOKER
	|	EXTERNAL SECURITY IMPLEMENTATION DEFINED

<parameter style> ::= SQL | GENERAL

<deterministic characteristic> ::= DETERMINISTIC | NOT DETERMINISTIC

<SQL-data access indication> ::=
		NO SQL
	|	CONTAINS SQL
	|	READS SQL DATA
	|	MODIFIES SQL DATA

<null-call clause> ::=
		RETURNS NULL ON NULL INPUT
	|	CALLED ON NULL INPUT

<maximum dynamic result sets> ::= unsigned_integer

<transform group specification> ::= TRANSFORM GROUP { <single group specification> | <multiple group specification> }

<single group specification> ::= <group name>

<multiple group specification> ::= <group specification> [ { COMMA <group specification> }... ]

<group specification> ::= <group name> FOR TYPE <path-resolved user-defined type name>

--h3 11.51 <alter routine statement> (p698)
--/h3

/* 
Alter a characteristic of an SQL-invoked routine.
*/

<alter routine statement> ::= ALTER <specific routine designator> <alter routine characteristics> <alter routine behavior>

<alter routine characteristics> ::= <alter routine characteristic>...

<alter routine characteristic> ::=
		<language clause>
	|	<parameter style clause>
	|	<SQL-data access indication>
	|	<null-call clause>
	|	<dynamic result sets characteristic>
	|	NAME <external routine name>

<alter routine behavior> ::= RESTRICT

--h3 11.52 <drop routine statement> (p701)
--/h3

/* 
Destroy an SQL-invoked routine.
*/

<drop routine statement> ::= DROP <specific routine designator> <drop behavior>

--h3 11.53 <user-defined cast definition> (p703)
--/h3

/* 
Define a user-defined cast.
*/

<user-defined cast definition> ::=
		CREATE CAST LPAR <source data type> AS <target data type> RPAR
		WITH <cast function> [ AS ASSIGNMENT ]

<cast function> ::= <specific routine designator>

<source data type> ::= <data type>

<target data type> ::= <data type>

--h3 11.54 <drop user-defined cast statement> (p705)
--/h3

/* 
Destroy a user-defined cast.
*/

<drop user-defined cast statement> ::=
		DROP CAST LPAR <source data type> AS <target data type> RPAR <drop behavior>

--h3 11.55 <user-defined ordering definition> (p707)
--/h3

/* 
Define a user-defined ordering for a user-defined type.
*/

<user-defined ordering definition> ::=
		CREATE ORDERING FOR <schema-resolved user-defined type name> <ordering form>

<ordering form> ::= <equals ordering form> | <full ordering form>

<equals ordering form> ::= EQUALS ONLY BY <ordering category>

<full ordering form> ::= ORDER FULL BY <ordering category>

<ordering category> ::= <relative category> | <map category> | <state category>

<relative category> ::= RELATIVE WITH <relative function specification>

<map category> ::= MAP WITH <map function specification>

<state category> ::= STATE [ <specific name> ]

<relative function specification> ::= <specific routine designator>

<map function specification> ::= <specific routine designator>

--h3 11.56 <drop user-defined ordering statement> (p710)
--/h3

/* 
Destroy a user-defined ordering method.
*/

<drop user-defined ordering statement> ::=
		DROP ORDERING FOR <schema-resolved user-defined type name> <drop behavior>

--h3 11.57 <transform definition> (p712)
--/h3

/* 
Define one or more transform functions for a user-defined type.
*/

<transform definition> ::= CREATE { TRANSFORM | TRANSFORMS } FOR <schema-resolved user-defined type name> <transform group>...

<transform group> ::= <group name> LPAR <transform element list> RPAR

<group name> ::= <identifier>

<transform element list> ::= <transform element> [ COMMA <transform element> ]

<transform element> ::= <to sql> | <from sql>

<to sql> ::= TO SQL WITH <to sql function>

<from sql> ::= FROM SQL WITH <from sql function>

<to sql function> ::= <specific routine designator>

<from sql function> ::= <specific routine designator>

--h3 11.58 <alter transform statement> (p715)
--/h3

/* 
Change the definition of one or more transform groups.
*/

<alter transform statement> ::=
		ALTER { TRANSFORM | TRANSFORMS } FOR <schema-resolved user-defined type name> <alter group>...

<alter group> ::= <group name> LPAR <alter transform action list> RPAR

<alter transform action list> ::= <alter transform action> [ { COMMA <alter transform action> }... ]

<alter transform action> ::= <add transform element list> | <drop transform element list>

--h3 11.59 <add transform element list> (p717)
--/h3

/* 
Add a transform element (<to sql> and/or <from sql>) to an existing transform group.
*/

<add transform element list> ::= ADD LPAR <transform element list> RPAR

--h3 11.60 <drop transform element list> (p719)
--/h3

/* 
Remove a transform element (<to sql> and/or <from sql>) from a transform group.
*/

<drop transform element list> ::= DROP LPAR <transform kind> [ COMMA <transform kind> ] <drop behavior> RPAR

<transform kind> ::= TO SQL | FROM SQL

--h3 11.61 <drop transform statement> (p721)
--/h3

/* 
Remove one or more transform functions associated with a transform.
*/

<drop transform statement> ::=
		DROP { TRANSFORM | TRANSFORMS } <transforms to be dropped> FOR <schema-resolved user-defined type name> <drop behavior>

<transforms to be dropped> ::= ALL | <transform group element>

<transform group element> ::= <group name>

--h3 11.62 <sequence generator definition> (p724)
--/h3

/* 
Define an external sequence generator.
*/

<sequence generator definition> ::= CREATE SEQUENCE <sequence generator name> [ <sequence generator options> ]

<sequence generator options> ::= <sequence generator option> ...

<sequence generator option> ::= <sequence generator data type option> | <common sequence generator options>

<common sequence generator options> ::= <common sequence generator option> ...

<common sequence generator option> ::= <sequence generator start with option> | <basic sequence generator option>

<basic sequence generator option> ::=
		<sequence generator increment by option>
	|	<sequence generator maxvalue option>
	|	<sequence generator minvalue option>
	|	<sequence generator cycle option>

<sequence generator data type option> ::= AS <data type>

<sequence generator start with option> ::= START WITH <sequence generator start value>

<sequence generator start value> ::= signed_numeric_literal

<sequence generator increment by option> ::= INCREMENT BY <sequence generator increment>

<sequence generator increment> ::= signed_numeric_literal

<sequence generator maxvalue option> ::=
		MAXVALUE <sequence generator max value>
	|	NO MAXVALUE

<sequence generator max value> ::= signed_numeric_literal

<sequence generator minvalue option> ::= MINVALUE <sequence generator min value> | NO MINVALUE

<sequence generator min value> ::= signed_numeric_literal

<sequence generator cycle option> ::= CYCLE | NO CYCLE

--h3 11.63 <alter sequence generator statement> (p726)
--/h3

/* 
Change the definition of an external sequence generator.
*/

<alter sequence generator statement> ::=
		ALTER SEQUENCE <sequence generator name> <alter sequence generator options>

<alter sequence generator options> ::= <alter sequence generator option>...

<alter sequence generator option> ::=
		<alter sequence generator restart option>
	|	<basic sequence generator option>

<alter sequence generator restart option> ::= RESTART WITH <sequence generator restart value>

<sequence generator restart value> ::= signed_numeric_literal

--h3 11.64 <drop sequence generator statement> (p727)
--/h3

/* 
Destroy an external sequence generator.
*/

<drop sequence generator statement> ::= DROP SEQUENCE <sequence generator name> <drop behavior>

--hr
--h2 12 Access control
--/h2

--h3 12.1 <grant statement> (p729)
--/h3

/* 
Define privileges and role authorizations.
*/

<grant statement> ::= <grant privilege statement> | <grant role statement>

--h3 12.2 <grant privilege statement> (p734)
--/h3

/* 
Define privileges.
*/

<grant privilege statement> ::=
		GRANT <privileges> TO <grantee> [ { COMMA <grantee> }... ]
		[ WITH HIERARCHY OPTION ] [ WITH GRANT OPTION ] [ GRANTED BY <grantor> ]

--h3 12.3 <privileges> (p737)
--/h3

/* 
Specify privileges.
*/

<privileges> ::= <object privileges> ON <object name>

<object name> ::=
		[ TABLE ] <table name>
	|	DOMAIN <domain name>
	|	COLLATION <collation name>
	|	CHARACTER SET <character set name>
	|	TRANSLATION <transliteration name>
	|	TYPE <schema-resolved user-defined type name>
	|	SEQUENCE <sequence generator name>
	|	<specific routine designator>

<object privileges> ::=
		ALL PRIVILEGES
	|	<action> [ { COMMA <action> }... ]

<action> ::=
		SELECT
	|	SELECT LPAR <privilege column list> RPAR
	|	SELECT LPAR <privilege method list> RPAR
	|	DELETE
	|	INSERT [ LPAR <privilege column list> RPAR ]
	|	UPDATE [ LPAR <privilege column list> RPAR ]
	|	REFERENCES [ LPAR <privilege column list> RPAR ]
	|	USAGE
	|	TRIGGER
	|	UNDER
	|	EXECUTE

<privilege method list> ::= <specific routine designator> [ { COMMA <specific routine designator> }... ]

<privilege column list> ::= <column name list>

<grantee> ::= PUBLIC | <authorization identifier>

<grantor> ::= CURRENT_USER | CURRENT_ROLE

--h3 12.4 <role definition> (p741)
--/h3

/* 
Define a role.
*/

<role definition> ::= CREATE ROLE <role name> [ WITH ADMIN <grantor> ]

--h3 12.5 <grant role statement> (p742)
--/h3

/* 
Define role authorizations.
*/

<grant role statement> ::=
		GRANT <role granted> [ { COMMA <role granted> }... ]
		TO <grantee> [ { COMMA <grantee> }... ] [ WITH ADMIN OPTION ] [ GRANTED BY <grantor> ]

<role granted> ::= <role name>

--h3 12.6 <drop role statement> (p744)
--/h3

/* 
Destroy a role.
*/

<drop role statement> ::= DROP ROLE <role name>

--h3 12.7 <revoke statement> (p745)
--/h3

/* 
Destroy privileges and role authorizations.
*/

<revoke statement> ::=
		<revoke privilege statement>
	|	<revoke role statement>

<revoke privilege statement> ::=
		REVOKE [ <revoke option extension> ] <privileges> FROM <grantee> [ { COMMA <grantee> }... ]
		[ GRANTED BY <grantor> ] <drop behavior>

<revoke option extension> ::= GRANT OPTION FOR | HIERARCHY OPTION FOR

<revoke role statement> ::=
		REVOKE [ ADMIN OPTION FOR ] <role revoked> [ { COMMA <role revoked> }... ]
		FROM <grantee> [ { COMMA <grantee> }... ] [ GRANTED BY <grantor> ] <drop behavior>

<role revoked> ::= <role name>

--hr
--h2 13 SQL-client modules
--/h2

--h3 13.1 <SQL-client module definition> (p763)
--/h3

/* 
Define an SQL-client module.
*/

<SQL-client module definition> ::=
		<module name clause> <language clause> <module authorization clause>
		[ <module path specification> ]
		[ <module transform group specification> ]
		[ <module collation> ]
		[ temporary_table_declaration... ]
		<module contents>...

<module authorization clause> ::=
		SCHEMA <schema name>
	|	AUTHORIZATION <module authorization identifier> [ FOR STATIC { ONLY | AND DYNAMIC } ]
	|	SCHEMA <schema name> AUTHORIZATION <module authorization identifier> [ FOR STATIC { ONLY | AND DYNAMIC } ]

<module authorization identifier> ::= <authorization identifier>

<module path specification> ::= <path specification>

<module transform group specification> ::= <transform group specification>

<module collations> ::= <module collation specification>...

<module collation specification> ::= COLLATION <collation name> [ FOR <character set specification list> ]

<character set specification list> ::= <character set specification> [ { COMMA <character set specification> }... ]

<module contents> ::=
		<declare cursor>
	|	<dynamic declare cursor>
	|	<externally-invoked procedure>

--h3 13.2 <module name clause> (p768)
--/h3

/* 
Name an SQL-client module.
*/

<module name clause> ::=
		MODULE [ <SQL-client module name> ] [ <module character set specification> ]

<module character set specification> ::= NAMES ARE <character set specification>

--h3 13.3 <externally-invoked procedure> (p769)
--/h3

/* 
Define an externally-invoked procedure.
*/

<externally-invoked procedure> ::=
		PROCEDURE <procedure name> <host parameter declaration list> SEMICOLON
		<SQL procedure statement> SEMICOLON

<host parameter declaration list> ::=
		LPAR <host parameter declaration> [ { COMMA <host parameter declaration> }... ] RPAR

<host parameter declaration> ::=
		<host parameter name> <host parameter data type>
	|	<status parameter>

<host parameter data type> ::= <data type> [ <locator indication> ]

<status parameter> ::= SQLSTATE

--h3 13.4 Calls to an <externally-invoked procedure> (p772)
--/h3

--h3 13.5 <SQL procedure statement> (p788)
--/h3

/* 
Define all of the SQL-statements that are <SQL procedure statement>s.
*/

<SQL procedure statement> ::= <SQL executable statement>

<SQL executable statement> ::=
		SQL_schema_statement
	|	<SQL data statement>
	|	<SQL control statement>
	|	SQL_transaction_statement
	|	SQL_connection_statement
	|	SQL_session_statement
	|	<SQL diagnostics statement>
	|	<SQL dynamic statement>

SQL_schema_statement ::=
		<SQL schema definition statement>
	|	<SQL schema manipulation statement>

<SQL schema definition statement> ::=
		<schema definition>
	|	<table definition>
	|	<view definition>
	|	<SQL-invoked routine>
	|	<grant statement>
	|	<role definition>
	|	<domain definition>
	|	<character set definition>
	|	<collation definition>
	|	<transliteration definition>
	|	<assertion definition>
	|	<trigger definition>
	|	<user-defined type definition>
	|	<user-defined cast definition>
	|	<user-defined ordering definition>
	|	<transform definition>
	|	<sequence generator definition>

<SQL schema manipulation statement> ::=
		<drop schema statement>
	|	<alter table statement>
	|	<drop table statement>
	|	<drop view statement>
	|	<alter routine statement>
	|	<drop routine statement>
	|	<drop user-defined cast statement>
	|	<revoke statement>
	|	<drop role statement>
	|	<alter domain statement>
	|	<drop domain statement>
	|	<drop character set statement>
	|	<drop collation statement>
	|	<drop transliteration statement>
	|	<drop assertion statement>
	|	<drop trigger statement>
	|	<alter type statement>
	|	<drop data type statement>
	|	<drop user-defined ordering statement>
	|	<alter transform statement>
	|	<drop transform statement> | <alter sequence generator statement>
	|	<drop sequence generator statement>

<SQL data statement> ::=
		<open statement>
	|	<fetch statement>
	|	<close statement>
	|	<select statement: single row>
	|	<free locator statement>
	|	<hold locator statement>
	|	<SQL data change statement>

<SQL data change statement> ::=
		<delete statement: positioned>
	|	delete_statement_searched
	|	insert_statement
	|	<update statement: positioned>
	|	update_statement_searched
	|	merge_statement

<SQL control statement> ::=
		<call statement>
	|	<return statement>

SQL_transaction_statement ::=
		<start transaction statement>
	|	<set transaction statement>
	|	<set constraints mode statement>
	|	<savepoint statement>
	|	<release savepoint statement>
	|	<commit statement>
	|	<rollback statement>

SQL_connection_statement ::=
		<connect statement>
	|	<set connection statement>
	|	<disconnect statement>

SQL_session_statement ::=
		<set session user identifier statement>
	|	<set role statement>
	|	<set local time zone statement>
	|	<set session characteristics statement>
	|	<set catalog statement>
	|	<set schema statement>
	|	<set names statement>
	|	<set path statement>
	|	<set transform group statement>
	|	<set session collation statement>

<SQL diagnostics statement> ::= get_diagnostics_statement

<SQL dynamic statement> ::=
		<system descriptor statement>
	|	<prepare statement>
	|	<deallocate prepared statement>
	|	<describe statement>
	|	<execute statement>
	|	<execute immediate statement>
	|	<SQL dynamic data statement>

<SQL dynamic data statement> ::=
		<allocate cursor statement>
	|	<dynamic open statement>
	|	<dynamic fetch statement>
	|	<dynamic close statement>
	|	<dynamic delete statement: positioned>
	|	<dynamic update statement: positioned>

<system descriptor statement> ::=
		<allocate descriptor statement>
	|	<deallocate descriptor statement>
	|	<set descriptor statement>
	|	<get descriptor statement>

--h3 13.6 Data type correspondences (p796)
--/h3

Table 16 -- Data type correspondences for C

--## <table border=1>
--## <tr><th> SQL Data Type </th><th> C Data Type </th></tr>

--## <tr><td> SQLSTATE </td><td> char, with length 6 </td></tr>
--## <tr><td> CHARACTER (L)<sup>3</sup> </td><td> char, with length (L+1)*k<sup>1</sup> </td></tr>
--## <tr><td> CHARACTER VARYING (L)<sup>3</sup> </td><td> char, with length (L+1)*k<sup>1</sup> </td></tr>
--## <tr><td> CHARACTER LARGE OBJECT(L) </td><td>
--## <pre>
--## struct {
--## long hvn<sup>3</sup>_reserved
--## unsigned long hvn<sup>2</sup>_length
--## char<sup>3</sup> hvn<sup>2</sup>_data[L];
--## } hvn<sup>2</sup>
--## </pre> </td></tr>
--## <tr><td> BINARY LARGE OBJECT(L) </td><td>
--## <pre> struct {
--## long hvn<sup>2</sup>_reserved
--## unsigned long hvn<sup>2</sup>_length
--## char hvn<sup>2</sup>_data[L];
--## } hvn<sup>2</sup>
--## </pre> </td></tr>
--## <tr><td> NUMERIC(P,S) </td><td> None </td></tr>
--## <tr><td> DECIMAL(P,S) </td><td> None </td></tr>
--## <tr><td> SMALLINT </td><td> pointer to short </td></tr>
--## <tr><td> INTEGER </td><td> pointer to long </td></tr>
--## <tr><td> BIGINT </td><td> pointer to long long </td></tr>
--## <tr><td> FLOAT(P) </td><td> None </td></tr>
--## <tr><td> REAL </td><td> pointer to float </td></tr>
--## <tr><td> DOUBLE PRECISION </td><td> pointer to double </td></tr>
--## <tr><td> BOOLEAN </td><td> pointer to long </td></tr>
--## <tr><td> DATE </td><td> None </td></tr>
--## <tr><td> TIME(T) </td><td> None </td></tr>
--## <tr><td> TIMESTAMP(T) </td><td> None </td></tr>
--## <tr><td> INTERVAL(Q) </td><td> None </td></tr>
--## <tr><td> user-defined type </td><td> None </td></tr>
--## <tr><td> REF </td><td> char, with length N </td></tr>
--## <tr><td> ROW </td><td> None </td></tr>
--## <tr><td> ARRAY </td><td> None </td></tr>
--## <tr><td> MULTISET </td><td> None </td></tr>
--## </table>

/*
--## <sup>1</sup> For character set UTF16, as well as other
implementation-defined character sets in which a code unit occupies two
octets, k is the length in units of C unsigned short of the character
encoded using the greatest number of such units in the character set;
for character set UTF32, as well as other implementation-defined
character sets in which a code unit occupies four octets, k is four; for
other character sets, k is the length in units of C char of the
character encoded using the greatest number of such units in the
character set.
--br
--## <sup>2</sup> hvn is the name of the host variable defined to correspond
to the SQL data type
--br
--## <sup>3</sup> For character set UTF16, as well as other
implementation-defined character sets in which a code unit occupies two
octets, char or unsigned char should be replaced with unsigned short;
for character set UTF32, as well as other implementation-defined
character sets in which a code unit occupies four octets, char or
unsigned char should be replaced with unsigned int.  Otherwise, char or
unsigned char should be used.
*/

--hr
--h2 14 Data manipulation
--/h2

--h3 14.1 <declare cursor> (p807)
--/h3

/* 
Define a cursor.
*/

<declare cursor> ::=
		DECLARE <cursor name> [ <cursor sensitivity> ] [ <cursor scrollability> ] CURSOR
		[ <cursor holdability> ] [ <cursor returnability> ] FOR cursor_specification

<cursor sensitivity> ::= SENSITIVE | INSENSITIVE | ASENSITIVE

<cursor scrollability> ::= SCROLL | NO SCROLL

<cursor holdability> ::= WITH HOLD | WITHOUT HOLD

<cursor returnability> ::= WITH RETURN | WITHOUT RETURN

cursor_specification ::= <query expression> [ <order by clause> ] [ <updatability clause> ] 

<updatability clause> ::= FOR { READ ONLY | UPDATE [ OF <column name list> ] }

<order by clause> ::= ORDER BY <sort specification list>

--h3 14.2 <open statement> (p813)
--/h3

/* 
Open a cursor.
*/

<open statement> ::= OPEN <cursor name>

--h3 14.3 <fetch statement> (p815)
--/h3

/* 
Position a cursor on a specified row of a table and retrieve values from that row.
*/

<fetch statement> ::=
		FETCH [ [ <fetch orientation> ] FROM ] <cursor name> INTO <fetch target list>

<fetch orientation> ::=
		NEXT
	|	PRIOR
	|	FIRST
	|	LAST
	|	{ ABSOLUTE | RELATIVE } simple_value_specification

<fetch target list> ::= <target specification> [ { COMMA <target specification> }... ]

--h3 14.4 <close statement> (p820)
--/h3

/*
Close a cursor.
*/

<close statement> ::= CLOSE <cursor name>

--h3 14.5 <select statement: single row> (p822)
--/h3

/* 
Retrieve values from a specified row of a table.
*/

<select statement: single row> ::=
		SELECT [ <set quantifier> ] <select list> INTO <select target list> <table expression>

<select target list> ::= <target specification> [ { COMMA <target specification> }... ]

--h3 14.6 <delete statement: positioned> (p826)
--/h3

/* 
Delete a row of a table.
*/

<delete statement: positioned> ::= DELETE FROM <target table> WHERE CURRENT OF <cursor name>

<target table> ::=
		<table name>
	|	ONLY LPAR <table name> RPAR

--h3 14.7 delete_statement_searched (p829)
--/h3

/* 
Delete rows of a table.
*/

delete_statement_searched ::= DELETE FROM <target table> [ WHERE <search condition> ]

--h3 14.8 insert_statement (p832)
--/h3

/* 
Create new rows in a table.
*/

insert_statement ::= INSERT INTO <insertion target> <insert columns and source>

<insertion target> ::= <table name>

<insert columns and source> ::=
		<from subquery>
	|	<from constructor>
	|	<from default>

<from subquery> ::= [ LPAR <insert column list> RPAR ] [ <override clause> ] <query expression>

<from constructor> ::=
		[ LPAR <insert column list> RPAR ] [ <override clause> ] <contextually typed table value constructor>

<override clause> ::= OVERRIDING USER VALUE | OVERRIDING SYSTEM VALUE

<from default> ::= DEFAULT VALUES

<insert column list> ::= <column name list>

--h3 14.9 merge_statement (p837)
--/h3

/* 
Conditionally update rows of a table, or insert new rows into a table, or both.
*/

merge_statement ::=
		MERGE INTO <target table> [ [ AS ] <merge correlation name> ]
		USING <table reference> ON <search condition> <merge operation specification>

<merge correlation name> ::= <correlation name>

<merge operation specification> ::= <merge when clause>...

<merge when clause> ::= <merge when matched clause> | <merge when not matched clause>

<merge when matched clause> ::= WHEN MATCHED THEN <merge update specification>

<merge when not matched clause> ::= WHEN NOT MATCHED THEN <merge insert specification>

<merge update specification> ::= UPDATE SET <set clause list>

<merge insert specification> ::=
		INSERT [ LPAR <insert column list> RPAR ]
		[ <override clause> ] VALUES <merge insert value list>

<merge insert value list> ::=
		LPAR <merge insert value element> [ { COMMA <merge insert value element> }... ] RPAR

<merge insert value element> ::= <value expression> | <contextually typed value specification>

--h3 14.10 <update statement: positioned> (p844)
--/h3

/* 
Update a row of a table.
*/

<update statement: positioned> ::= UPDATE <target table> SET <set clause list> WHERE CURRENT OF <cursor name>

--h3 14.11 update_statement_searched (p847)
--/h3

/* 
Update rows of a table.
*/

update_statement_searched ::= UPDATE <target table> SET <set clause list> [ WHERE <search condition> ]

--h3 14.12 <set clause list> (p851)
--/h3

/* 
Specify a list of updates.
*/

<set clause list> ::= <set clause> [ { COMMA <set clause> }... ]

<set clause> ::=
		<multiple column assignment>
	|	<set target> EQ <update source>

<set target> ::= <update target> | <mutated set clause>

<multiple column assignment> ::= <set target list> EQ <assigned row>

<set target list> ::= LPAR <set target> [ { COMMA <set target> }... ] RPAR

<assigned row> ::= <contextually typed row value expression>

<update target> ::=
		<object column>
	|	<object column> left_bracket_or_trigraph simple_value_specification right_bracket_or_trigraph

<object column> ::= <column name>

<mutated set clause> ::= <mutated target> DOT <method name>

<mutated target> ::= <object column> | <mutated set clause>

<update source> ::= <value expression> | <contextually typed value specification>

--h3 14.13 temporary_table_declaration (p856)
--/h3

/* 
Declare a declared local temporary table.
*/

temporary_table_declaration ::=
		DECLARE LOCAL TEMPORARY TABLE <table name> <table element list>
		[ ON COMMIT <table commit action> ROWS ]

--h3 14.14 <free locator statement> (p858)
--/h3

/* 
Remove the association between a locator variable and the value that is represented by that locator.
*/

<free locator statement> ::= FREE LOCATOR <locator reference> [ { COMMA <locator reference> }... ]

<locator reference> ::= <host parameter name> | <embedded variable name>

--h3 14.15 <hold locator statement> (p859)
--/h3

/* 
Mark a locator variable as being holdable.
*/

<hold locator statement> ::= HOLD LOCATOR <locator reference> [ { COMMA <locator reference> }... ]

--h3 14.16 Effect of deleting rows from base tables (p860)
--/h3

--h3 14.17 Effect of deleting some rows from a derived table (p862)
--/h3

--h3 14.18 Effect of deleting some rows from a viewed table (p864)
--/h3

--h3 14.19 Effect of inserting tables into base tables (p865)
--/h3

--h3 14.20 Effect of inserting a table into a derived table (p867)
--/h3

--h3 14.21 Effect of inserting a table into a viewed table (p869)
--/h3

--h3 14.22 Effect of replacing rows in base tables (p871)
--/h3

--h3 14.23 Effect of replacing some rows in a derived table (p874)
--/h3

--h3 14.24 Effect of replacing some rows in a viewed table (p877)
--/h3

--h3 14.25 Execution of BEFORE triggers (p879)
--/h3

--h3 14.26 Execution of AFTER triggers (p880)
--/h3

--h3 14.27 Execution of triggers (p881)
--/h3

--hr
--h2 15 Control statements
--/h2

--h3 15.1 <call statement> (p883)
--/h3

/* 
Invoke an SQL-invoked routine.
*/

<call statement> ::= CALL <routine invocation>

--h3 15.2 <return statement> (p884)
--/h3

/* 
Return a value from an SQL function.
*/

<return statement> ::= RETURN <return value>

<return value> ::= <value expression> | NULL

--hr
--h2 16 Transaction management
--/h2

--h3 16.1 <start transaction statement> (p885)
--/h3

/* 
Start an SQL-transaction and set its characteristics.
*/

<start transaction statement> ::= START TRANSACTION [ <transaction mode> [ { COMMA <transaction mode> }...] ]

<transaction mode> ::= <isolation level> | <transaction access mode> | <diagnostics size>

<transaction access mode> ::= READ ONLY | READ WRITE

<isolation level> ::= ISOLATION LEVEL <level of isolation>

<level of isolation> ::= READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE

<diagnostics size> ::= DIAGNOSTICS SIZE <number of conditions>

<number of conditions> ::= simple_value_specification

--h3 16.2 <set transaction statement> (p888)
--/h3

/* 
Set the characteristics of the next SQL-transaction for the SQL-agent.
NOTE 402 - This statement has no effect on any SQL-transactions subsequent to the next SQL-transaction.
*/

<set transaction statement> ::= SET [ LOCAL ] <transaction characteristics>

<transaction characteristics> ::= TRANSACTION <transaction mode> [ { COMMA <transaction mode> }... ]

--h3 16.3 <set constraints mode statement> (p890)
--/h3

/* 
If an SQL-transaction is currently active, then set the constraint mode for that SQL-transaction in
the current SQL-session. If no SQL-transaction is currently active, then set the constraint mode for
the next SQL-transaction in the current SQL-session for the SQL-agent.
NOTE 404  This statement has no effect on any SQL-transactions subsequent to this SQL-transaction.
*/

<set constraints mode statement> ::= SET CONSTRAINTS <constraint name list> { DEFERRED | IMMEDIATE }

<constraint name list> ::= ALL | constraint_name [ { COMMA constraint_name }... ]

--h3 16.4 <savepoint statement> (p892)
--/h3

/* 
Establish a savepoint.
*/

<savepoint statement> ::= SAVEPOINT <savepoint specifier>

<savepoint specifier> ::= <savepoint name>

--h3 16.5 <release savepoint statement> (p893)
--/h3

/* 
Destroy a savepoint.
*/

<release savepoint statement> ::= RELEASE SAVEPOINT <savepoint specifier>

--h3 16.6 <commit statement> (p894)
--/h3

/* 
Terminate the current SQL-transaction with commit.
*/

<commit statement> ::= COMMIT [ WORK ] [ AND [ NO ] CHAIN ]

--h3 16.7 <rollback statement> (p896)
--/h3

/* 
Terminate the current SQL-transaction with rollback, or rollback all actions affecting SQL-data
and/or schemas since the establishment of a savepoint.
*/

<rollback statement> ::= ROLLBACK [ WORK ] [ AND [ NO ] CHAIN ] [ <savepoint clause> ]

<savepoint clause> ::= TO SAVEPOINT <savepoint specifier>

--hr
--h2 17 Connection management
--/h2

--h3 17.1 <connect statement> (p899)
--/h3

/* 
Establish an SQL-session.
*/

<connect statement> ::= CONNECT TO <connection target>

<connection target> ::=
		<SQL-server name> [ AS <connection name> ] [ USER <connection user name> ]
	|	DEFAULT

--h3 17.2 <set connection statement> (p902)
--/h3

/* 
Select an SQL-connection from the available SQL-connections.
*/

<set connection statement> ::= SET CONNECTION <connection object>

<connection object> ::= DEFAULT | <connection name> 

--h3 17.3 <disconnect statement> (p904)
--/h3

/* 
Terminate an SQL-connection.
*/

<disconnect statement> ::= DISCONNECT <disconnect object>

<disconnect object> ::= <connection object> | ALL |	CURRENT

--hr
--h2 18 Session management
--/h2

--h3 18.1 <set session characteristics statement> (p907)
--/h3

/* 
Set one or more characteristics for the current SQL-session.
*/

<set session characteristics statement> ::= SET SESSION CHARACTERISTICS AS <session characteristic list>

<session characteristic list> ::= <session characteristic> [ { COMMA <session characteristic> }... ]

<session characteristic> ::= <transaction characteristics>

--h3 18.2 <set session user identifier statement> (p908)
--/h3

/* 
Set the SQL-session user identifier and the current user identifier of the current SQL-session
context.
*/

<set session user identifier statement> ::= SET SESSION AUTHORIZATION <value specification>

--h3 18.3 <set role statement> (p909)
--/h3

/* 
Set the current role name for the current SQL-session context.
*/

<set role statement> ::= SET ROLE <role specification>

<role specification> ::= <value specification> | NONE

--h3 18.4 <set local time zone statement> (p911)
--/h3

/* 
Set the default local time zone displacement for the current SQL-session.
*/

<set local time zone statement> ::= SET TIME ZONE <set time zone value>

<set time zone value> ::= <interval value expression> | LOCAL

--h3 18.5 <set catalog statement> (p912)
--/h3

/* 
Set the default catalog name for unqualified <schema name>s in <preparable statement>s that
are prepared in the current SQL-session by an <execute immediate statement> or a <prepare
statement> and in <direct SQL statement>s that are invoked directly.
*/

<set catalog statement> ::= SET <catalog name characteristic>

<catalog name characteristic> ::= CATALOG <value specification>

--h3 18.6 <set schema statement> (p913)
--/h3

/* 
Set the default schema name for unqualified <schema qualified name>s in <preparable statement>s
that are prepared in the current SQL-session by an <execute immediate statement> or a <prepare
statement> and in <direct SQL statement>s that are invoked directly.
*/

<set schema statement> ::= SET <schema name characteristic>

<schema name characteristic> ::= SCHEMA <value specification>

--h3 18.7 <set names statement> (p915)
--/h3

/* 
Set the default character set name for <character string literal>s in <preparable statement>s that
are prepared in the current SQL-session by an <execute immediate statement> or a <prepare
statement> and in <direct SQL statement>s that are invoked directly.
*/

<set names statement> ::= SET <character set name characteristic>

<character set name characteristic> ::= NAMES <value specification>

--h3 18.8 <set path statement> (p916)
--/h3

/* 
Set the SQL-path used to determine the subject routine of <routine invocation>s with unqualified
<routine name>s in <preparable statement>s that are prepared in the current SQL-session by
an <execute immediate statement> or a <prepare statement> and in <direct SQL statement>s,
respectively, that are invoked directly. The SQL-path remains the current SQL-path of the SQLsession
until another SQL-path is successfully set.
*/

<set path statement> ::= SET <SQL-path characteristic>

<SQL-path characteristic> ::= PATH <value specification>

--h3 18.9 <set transform group statement> (p917)
--/h3

/* 
Set the group name that identifies the group of transform functions for
mapping values of userdefined types to predefined data types.
*/

<set transform group statement> ::= SET <transform group characteristic>

<transform group characteristic> ::=
		DEFAULT TRANSFORM GROUP <value specification>
	|	TRANSFORM GROUP FOR TYPE <path-resolved user-defined type name> <value specification>

--h3 18.10 <set session collation statement> (p918)
--/h3

/* 
Set the SQL-session collation of the SQL-session for one or more
character sets.  An SQL-session collation remains effective until
another SQL-session collation for the same character set is successfully
set.
*/

<set session collation statement> ::=
		SET COLLATION <collation specification> [ FOR <character set specification list> ]
	|	SET NO COLLATION [ FOR <character set specification list> ]

<character set specification list> ::= <character set specification> [ , <character set specification>... ]

<collation specification> ::= <value specification>

--hr
--h2 19 Dynamic SQL

--h3 19.1 Description of SQL descriptor areas (p921)
--/h3

--h3 19.2 <allocate descriptor statement> (p931)
--/h3

/* 
Allocate an SQL descriptor area.
*/

<allocate descriptor statement> ::= ALLOCATE [ SQL ] DESCRIPTOR <descriptor name> [ WITH MAX <occurrences> ]

<occurrences> ::= simple_value_specification

--h3 19.3 <deallocate descriptor statement> (p933)
--/h3

/* 
Deallocate an SQL descriptor area.
*/

<deallocate descriptor statement> ::= DEALLOCATE [ SQL ] DESCRIPTOR <descriptor name>

--h3 19.4 <get descriptor statement> (p934)
--/h3

/* 
Get information from an SQL descriptor area.
*/

<get descriptor statement> ::= GET [ SQL ] DESCRIPTOR <descriptor name> <get descriptor information>

<get descriptor information> ::=
		<get header information> [ { COMMA <get header information> }... ]
	|	VALUE <item number> <get item information> [ { COMMA <get item information> }... ]

<get header information> ::= <simple target specification 1> EQ <header item name>

<header item name> ::= COUNT | KEY_TYPE | DYNAMIC_FUNCTION | DYNAMIC_FUNCTION_CODE | TOP_LEVEL_COUNT

<get item information> ::= <simple target specification 2> EQ <descriptor item name>

<item number> ::= simple_value_specification

<simple target specification 1> ::= simple_target_specification

<simple target specification 2> ::= simple_target_specification

<descriptor item name> ::=
		CARDINALITY
	|	CHARACTER_SET_CATALOG
	|	CHARACTER_SET_NAME
	|	CHARACTER_SET_SCHEMA
	|	COLLATION_CATALOG
	|	COLLATION_NAME
	|	COLLATION_SCHEMA
	|	DATA
	|	DATETIME_INTERVAL_CODE
	|	DATETIME_INTERVAL_PRECISION
	|	DEGREE
	|	INDICATOR
	|	KEY_MEMBER
	|	LENGTH
	|	LEVEL
	|	NAME
	|	NULLABLE
	|	OCTET_LENGTH
	|	PARAMETER_MODE
	|	PARAMETER_ORDINAL_POSITION
	|	PARAMETER_SPECIFIC_CATALOG
	|	PARAMETER_SPECIFIC_NAME
	|	PARAMETER_SPECIFIC_SCHEMA
	|	PRECISION
	|	RETURNED_CARDINALITY
	|	RETURNED_LENGTH
	|	RETURNED_OCTET_LENGTH
	|	SCALE
	|	SCOPE_CATALOG
	|	SCOPE_NAME
	|	SCOPE_SCHEMA
	|	TYPE
	|	UNNAMED
	|	USER_DEFINED_TYPE_CATALOG
	|	USER_DEFINED_TYPE_NAME
	|	USER_DEFINED_TYPE_SCHEMA
	|	USER_DEFINED_TYPE_CODE

--h3 19.5 <set descriptor statement> (p937)
--/h3

/* 
Set information in an SQL descriptor area.
*/

<set descriptor statement> ::= SET [ SQL ] DESCRIPTOR <descriptor name> <set descriptor information>

<set descriptor information> ::=
		<set header information> [ { COMMA <set header information> }... ]
	|	VALUE <item number> <set item information> [ { COMMA <set item information> }... ]

<set header information> ::= <header item name> EQ <simple value specification 1>

<set item information> ::= <descriptor item name> EQ <simple value specification 2>

<simple value specification 1> ::= simple_value_specification

<simple value specification 2> ::= simple_value_specification

<item number> ::= simple_value_specification

--h3 19.6 <prepare statement> (p941)
--/h3

/* 
Prepare a statement for execution.
*/

<prepare statement> ::=
		PREPARE <SQL statement name> [ <attributes specification> ] FROM <SQL statement variable>

<attributes specification> ::= ATTRIBUTES <attributes variable>

<attributes variable> ::= simple_value_specification

<SQL statement variable> ::= simple_value_specification

<preparable statement> ::=
		<preparable SQL data statement>
	|	<preparable SQL schema statement>
	|	<preparable SQL transaction statement>
	|	<preparable SQL control statement>
	|	<preparable SQL session statement>
	|	<preparable implementation-defined statement>

<preparable SQL data statement> ::=
		delete_statement_searched
	|	<dynamic single row select statement>
	|	insert_statement
	|	<dynamic select statement>
	|	update_statement_searched
	|	merge_statement
	|	<preparable dynamic delete statement: positioned>
	|	<preparable dynamic update statement: positioned>

<preparable SQL schema statement> ::= SQL_schema_statement

<preparable SQL transaction statement> ::= SQL_transaction_statement

<preparable SQL control statement> ::= <SQL control statement>

<preparable SQL session statement> ::= SQL_session_statement

<dynamic select statement> ::= cursor_specification

<preparable implementation-defined statement> ::= !! See the Syntax Rules.

--h3 19.7 <cursor attributes> (p953)
--/h3

/* 
Specify a list of cursor attributes.
*/

<cursor attributes> ::= <cursor attribute>...

<cursor attribute> ::=
		<cursor sensitivity>
	|	<cursor scrollability>
	|	<cursor holdability>
	|	<cursor returnability>

--h3 19.8 <deallocate prepared statement> (p954)
--/h3

/* 
Deallocate SQL-statements that have been prepared with a <prepare statement>.
*/

<deallocate prepared statement> ::= DEALLOCATE PREPARE <SQL statement name>

--h3 19.9 <describe statement> (p955)
--/h3

/* 
Obtain information about the <select list> columns or <dynamic parameter specification>s contained
in a prepared statement or about the columns of the result set associated with a cursor.
*/

<describe statement> ::= <describe input statement> | <describe output statement>

<describe input statement> ::= DESCRIBE INPUT <SQL statement name> <using descriptor> [ <nesting option> ]

<describe output statement> ::= DESCRIBE [ OUTPUT ] <described object> <using descriptor> [ <nesting option> ]

<nesting option> ::= WITH NESTING | WITHOUT NESTING

<using descriptor> ::= USING [ SQL ] DESCRIPTOR <descriptor name>

<described object> ::=
		<SQL statement name>
	|	CURSOR <extended cursor name> STRUCTURE

--h3 19.10 <input using clause> (p961)
--/h3

/* 
Supply input values for an <SQL dynamic statement>.
*/

<input using clause> ::= <using arguments> | <using input descriptor>

<using arguments> ::= USING <using argument> [ { COMMA <using argument> }... ]

<using argument> ::= <general value specification>

<using input descriptor> ::= <using descriptor>

--h3 19.11 <output using clause> (p965)
--/h3

/* 
Supply output variables for an <SQL dynamic statement>.
*/

<output using clause> ::= <into arguments> | <into descriptor>

<into arguments> ::= INTO <into argument> [ { COMMA <into argument> }... ]

<into argument> ::= <target specification>

<into descriptor> ::= INTO [ SQL ] DESCRIPTOR <descriptor name>

--h3 19.12 <execute statement> (p970)
--/h3

/* 
Associate input SQL parameters and output targets with a prepared statement and execute the
statement.
*/

<execute statement> ::= EXECUTE <SQL statement name> [ <result using clause> ] [ <parameter using clause> ]

<result using clause> ::= <output using clause>

<parameter using clause> ::= <input using clause>

--h3 19.13 <execute immediate statement> (p972)
--/h3

/* 
Dynamically prepare and execute a preparable statement.
*/

<execute immediate statement> ::= EXECUTE IMMEDIATE <SQL statement variable>

--h3 19.14 <dynamic declare cursor> (p973)
--/h3

/* 
Declare a cursor to be associated with a <statement name>, which may in turn be associated with a
cursor_specification.
*/

<dynamic declare cursor> ::=
		DECLARE <cursor name> [ <cursor sensitivity> ] [ <cursor scrollability> ] CURSOR
		[ <cursor holdability> ] [ <cursor returnability> ] FOR <statement name>

--h3 19.15 <allocate cursor statement> (p974)
--/h3

/* 
Define a cursor based on a prepared statement for a cursor_specification or assign a cursor to the
ordered set of result sets returned from an SQL-invoked procedure.
*/

<allocate cursor statement> ::= ALLOCATE <extended cursor name> <cursor intent>

<cursor intent> ::= <statement cursor> | <result set cursor>

<statement cursor> ::=
		[ <cursor sensitivity> ] [ <cursor scrollability> ] CURSOR
		[ <cursor holdability> ] [ <cursor returnability> ] FOR <extended statement name>

<result set cursor> ::= FOR PROCEDURE <specific routine designator>

--h3 19.16 <dynamic open statement> (p976)
--/h3

/* 
Associate input dynamic parameters with a cursor_specification and open the cursor.
*/

<dynamic open statement> ::= OPEN <dynamic cursor name> [ <input using clause> ]

--h3 19.17 <dynamic fetch statement> (p977)
--/h3

/* 
Fetch a row for a cursor declared with a <dynamic declare cursor>.
*/

<dynamic fetch statement> ::= FETCH [ [ <fetch orientation> ] FROM ] <dynamic cursor name> <output using clause>

--h3 19.18 <dynamic single row select statement> (p978)
--/h3

/* 
Retrieve values from a dynamically-specified row of a table.
*/

<dynamic single row select statement> ::= <query specification>

--h3 19.19 <dynamic close statement> (p979)
--/h3

/* 
Close a cursor.
*/

<dynamic close statement> ::= CLOSE <dynamic cursor name>

--h3 19.20 <dynamic delete statement: positioned> (p980)
--/h3

/* 
Delete a row of a table.
*/

<dynamic delete statement: positioned> ::= DELETE FROM <target table> WHERE CURRENT OF <dynamic cursor name>

--h3 19.21 <dynamic update statement: positioned> (p982)
--/h3

/* 
Update a row of a table.
*/

<dynamic update statement: positioned> ::=
		UPDATE <target table> SET <set clause list> WHERE CURRENT OF <dynamic cursor name>

--h3 19.22 <preparable dynamic delete statement: positioned> (p984)
--/h3

/* 
Delete a row of a table through a dynamic cursor.
*/

<preparable dynamic delete statement: positioned> ::=
		DELETE [ FROM <target table> ] WHERE CURRENT OF [ <scope option> ] <cursor name>

--h3 19.23 <preparable dynamic update statement: positioned> (p986)
--/h3

/* 
Update a row of a table through a dynamic cursor.
*/

<preparable dynamic update statement: positioned> ::=
		UPDATE [ <target table> ] SET <set clause list> WHERE CURRENT OF [ <scope option> ] <cursor name>

--hr
--h2 20 Embedded SQL
--/h2

--h3 20.1 <embedded SQL host program> (p989)
--/h3

/* 
Specify an <embedded SQL host program>.
*/

<embedded SQL host program> ::=
		<embedded SQL Ada program>
	|	<embedded SQL C program>
	|	<embedded SQL COBOL program>
	|	<embedded SQL Fortran program>
	|	<embedded SQL MUMPS program>
	|	<embedded SQL Pascal program>
	|	<embedded SQL PL/I program>

<embedded SQL statement> ::= <SQL prefix> <statement or declaration> [ <SQL terminator> ]

<statement or declaration> ::=
		<declare cursor>
	|	<dynamic declare cursor>
	|	temporary_table_declaration
	|	<embedded authorization declaration>
	|	<embedded path specification>
	|	<embedded transform group specification>
	|	<embedded collation specification>
	|	embedded_exception_declaration
	|	<handler declaration>
	|	<SQL procedure statement>

<SQL prefix> ::= EXEC SQL | <ampersand>SQL<left paren>

<SQL terminator> ::= END-EXEC | SEMICOLON | RPAR

<embedded authorization declaration> ::= DECLARE <embedded authorization clause>

<embedded authorization clause> ::=
		SCHEMA <schema name>
	|	AUTHORIZATION <embedded authorization identifier> [ FOR STATIC { ONLY | AND DYNAMIC } ]
	|	SCHEMA <schema name> AUTHORIZATION <embedded authorization identifier> [ FOR STATIC { ONLY | AND DYNAMIC } ]

<embedded authorization identifier> ::= <module authorization identifier>

<embedded path specification> ::= <path specification>

<embedded transform group specification> ::= <transform group specification>

<embedded collation specification> ::= <module collations>

<embedded SQL declare section> ::=
		<embedded SQL begin declare> [ <embedded character set declaration> ] [ <host variable definition>... ] <embedded SQL end declare>
	|	<embedded SQL MUMPS declare>

<embedded character set declaration> ::= SQL NAMES ARE <character set specification>

<embedded SQL begin declare> ::= <SQL prefix> BEGIN DECLARE SECTION [ <SQL terminator> ]

<embedded SQL end declare> ::= <SQL prefix> END DECLARE SECTION [ <SQL terminator> ]

<embedded SQL MUMPS declare> ::=
		<SQL prefix> BEGIN DECLARE SECTION [ <embedded character set declaration> ]
		[ <host variable definition>... ] END DECLARE SECTION <SQL terminator>

<host variable definition> ::=
		<Ada variable definition>
	|	<C variable definition>
	|	<COBOL variable definition>
	|	<Fortran variable definition>
	|	<MUMPS variable definition>
	|	<Pascal variable definition>
	|	<PL/I variable definition>

<embedded variable name> ::= COLON <host identifier>

<host identifier> ::=
		<Ada host identifier>
	|	<C host identifier>
	|	<COBOL host identifier>
	|	<Fortran host identifier>
	|	<MUMPS host identifier>
	|	<Pascal host identifier>
	|	<PL/I host identifier>

--h3 20.2 embedded_exception_declaration (p1001)
--/h3

/* 
Specify the action to be taken when an SQL-statement causes a specific class of condition to be
raised.
*/

embedded_exception_declaration ::= WHENEVER condition condition_action
                               ;

condition ::= SQL_condition
          ;
          
SQL_condition ::= major_category
              |	SQLSTATE ( <SQLSTATE class value> [ , <SQLSTATE subclass value> ] )
	            | CONSTRAINT constraint_name
	            ;

major_category ::= SQLEXCEPTION 
               |   SQLWARNING 
               |   NOT FOUND
               ;

<SQLSTATE class value> ::= <SQLSTATE char><SQLSTATE char> !! See the Syntax Rules.

<SQLSTATE subclass value> ::= <SQLSTATE char><SQLSTATE char><SQLSTATE char> !! See the Syntax Rules.

<SQLSTATE char> ::= <simple Latin upper case letter> | <digit>

condition_action ::= CONTINUE | <go to>

<go to> ::= { GOTO | GO TO } <goto target>

<goto target> ::=
		<host label identifier>
	|	unsigned_integer


<host label identifier> ::= !! See the Syntax Rules.




/* 
Specify an <embedded SQL C program>.
*/

/**************************************************************************************

<embedded SQL C program> ::= !! See the Syntax Rules.

<C variable definition> ::= [ <C storage class> ] [ <C class modifier> ] <C variable specification> SEMICOLON

<C variable specification> ::= <C numeric variable> | <C character variable> | <C derived variable>

<C storage class> ::= auto | extern | static

<C class modifier> ::= const | volatile

<C numeric variable> ::=
		{ long long | long | short | float | double } <C host identifier> [ <C initial value> ]
		[ { COMMA <C host identifier> [ <C initial value> ] }... ]

<C character variable> ::=
		<C character type> [ CHARACTER SET [ IS ] <character set specification> ]
		<C host identifier> <C array specification> [ <C initial value> ]
		[ { COMMA <C host identifier> <C array specification> [ <C initial value> ] }... ]

<C character type> ::= char | unsigned char | unsigned short

<C array specification> ::= LBRA <length> RBRA

<C host identifier> ::= !! See the Syntax Rules.

<C derived variable> ::=
		<C VARCHAR variable>
	|	<C NCHAR variable>
	|	<C NCHAR VARYING variable>
	|	<C CLOB variable>
	|	<C NCLOB variable>
	|	<C BLOB variable>
	|	<C user-defined type variable>
	|	<C CLOB locator variable>
	|	<C BLOB locator variable>
	|	<C array locator variable>
	|	<C multiset locator variable>
	|	<C user-defined type locator variable>
	|	<C REF variable>

<C VARCHAR variable> ::=
		VARCHAR [ CHARACTER SET [ IS ] <character set specification> ]
		<C host identifier> <C array specification> [ <C initial value> ]
		[ { COMMA <C host identifier> <C array specification> [ <C initial value> ] }... ]

<C NCHAR variable> ::=
		NCHAR [ CHARACTER SET [ IS ] <character set specification> ]
		<C host identifier> <C array specification> [ <C initial value> ]
		[ { COMMA <C host identifier> <C array specification> [ <C initial value> ] } ... ]

<C NCHAR VARYING variable> ::=
		NCHAR VARYING [ CHARACTER SET [ IS ] <character set specification> ]
		<C host identifier> <C array specification> [ <C initial value> ]
		[ { COMMA <C host identifier> <C array specification> [ <C initial value> ] } ... ]

<C CLOB variable> ::=
		SQL TYPE IS CLOB LPAR <large object length> RPAR
		[ CHARACTER SET [ IS ] <character set specification> ]
		<C host identifier> [ <C initial value> ]
		[ { COMMA <C host identifier> [ <C initial value> ] }... ]

<C NCLOB variable> ::=
		SQL TYPE IS NCLOB LPAR <large object length> RPAR
		[ CHARACTER SET [ IS ] <character set specification> ]
		<C host identifier> [ <C initial value> ]
		[ { COMMA <C host identifier> [ <C initial value> ] }... ]

<C user-defined type variable> ::=
		SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>
		<C host identifier> [ <C initial value> ]
		[ { COMMA <C host identifier> [ <C initial value> ] } ... ]

<C BLOB variable> ::=
		SQL TYPE IS BLOB LPAR <large object length> RPAR
		<C host identifier> [ <C initial value> ]
		[ { COMMA <C host identifier> [ <C initial value> ] } ... ]

<C CLOB locator variable> ::=
		SQL TYPE IS CLOB AS LOCATOR
		<C host identifier> [ <C initial value> ]
		[ { COMMA <C host identifier> [ <C initial value> ] } ... ]

<C BLOB locator variable> ::=
		SQL TYPE IS BLOB AS LOCATOR
		<C host identifier> [ <C initial value> ]
		[ { COMMA <C host identifier> [ <C initial value> ] } ... ]

<C array locator variable> ::=
		SQL TYPE IS <array type> AS LOCATOR
		<C host identifier> [ <C initial value> ]
		[ { COMMA <C host identifier> [ <C initial value> ] } ... ]

<C multiset locator variable> ::=
		SQL TYPE IS <multiset type> AS LOCATOR
		<C host identifier> [ <C initial value> ]
		[ { COMMA <C host identifier> [ <C initial value> ] } ... ]

<C user-defined type locator variable> ::=
		SQL TYPE IS
		<path-resolved user-defined type name> AS LOCATOR
		<C host identifier> [ <C initial value> ]
		[ { COMMA <C host identifier> [ <C initial value> ] }... ]

<C REF variable> ::= SQL TYPE IS <reference type>

<C initial value> ::= EQ <character representation>...

**************************************************************************************/

/* 
Specify an <embedded SQL COBOL program>.
*/

/**********************************************************************
SQL COBOL Embeded

<embedded SQL COBOL program> ::= !! See the Syntax Rules.

<COBOL variable definition> ::=
		{ 01 | 77 } <COBOL host identifier> <COBOL type specification>
		[ <character representation>... ] DOT

<COBOL host identifier> ::= !! See the Syntax Rules.

<COBOL type specification> ::=
		<COBOL character type>
	|	<COBOL national character type>
	|	<COBOL numeric type>
	|	<COBOL integer type>
	|	<COBOL derived type specification>

<COBOL derived type specification> ::=
		<COBOL CLOB variable>
	|	<COBOL NCLOB variable>
	|	<COBOL BLOB variable>
	|	<COBOL user-defined type variable>
	|	<COBOL CLOB locator variable>
	|	<COBOL BLOB locator variable>
	|	<COBOL array locator variable>
	|	<COBOL multiset locator variable>
	|	<COBOL user-defined type locator variable>
	|	<COBOL REF variable>

<COBOL character type> ::=
		[ CHARACTER SET [ IS ] <character set specification> ]
		{ PIC | PICTURE } [ IS ] { X [ LPAR <length> RPAR ] }...

<COBOL national character type> ::=
		[ CHARACTER SET [ IS ] <character set specification> ]
		{ PIC | PICTURE } [ IS ] { N [ LPAR <length> RPAR ] }...

<COBOL CLOB variable> ::=
		[ USAGE [ IS ] ]
		SQL TYPE IS CLOB LPAR <large object length> RPAR
		[ CHARACTER SET [ IS ] <character set specification> ]

<COBOL NCLOB variable> ::=
		[ USAGE [ IS ] ]
		SQL TYPE IS NCLOB LPAR <large object length> RPAR
		[ CHARACTER SET [ IS ] <character set specification> ]

<COBOL BLOB variable> ::=
		[ USAGE [ IS ] ]
		SQL TYPE IS BLOB LPAR <large object length> RPAR

<COBOL user-defined type variable> ::=
		[ USAGE [ IS ] ] SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>

<COBOL CLOB locator variable> ::=
		[ USAGE [ IS ] ] SQL TYPE IS CLOB AS LOCATOR

<COBOL BLOB locator variable> ::=
		[ USAGE [ IS ] ] SQL TYPE IS BLOB AS LOCATOR

<COBOL array locator variable> ::=
	[ USAGE [ IS ] ] SQL TYPE IS <array type> AS LOCATOR

<COBOL multiset locator variable> ::=
	[ USAGE [ IS ] ] SQL TYPE IS <multiset type> AS LOCATOR

<COBOL user-defined type locator variable> ::=
	[ USAGE [ IS ] ] SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR

<COBOL REF variable> ::= [ USAGE [ IS ] ] SQL TYPE IS <reference type>

<COBOL numeric type> ::=
		{ PIC | PICTURE } [ IS ] S <COBOL nines specification> [ USAGE [ IS ] ] DISPLAY SIGN LEADING SEPARATE

<COBOL nines specification> ::=
		<COBOL nines> [ V [ <COBOL nines> ] ]
	|	V <COBOL nines>

<COBOL integer type> ::= <COBOL binary integer>

<COBOL binary integer> ::= { PIC | PICTURE } [ IS ] S<COBOL nines> [ USAGE [ IS ] ] BINARY

<COBOL nines> ::= { 9 [ LPAR <length> RPAR ] }...

**********************************************************************/


/* 
Specify direct execution of SQL.
*/

direct_SQL_statement ::= directly_executable_statement SEMICOLON    
                     ;
 

directly_executable_statement ::= direct_SQL_data_statement
	                              |   SQL_schema_statement
	                              |   SQL_transaction_statement
	                              |   SQL_connection_statement
	                              |   SQL_session_statement
	                              |   direct_implementation_defined_statement
	                              ;   

direct_SQL_data_statement ::= delete_statement_searched
	                          |   direct_select_statement_multiple_rows
	                          |   insert_statement
	                          |   update_statement_searched
	                          |   merge_statement
	                          |   temporary_table_declaration
	                          ;   

direct_implementation_defined_statement ::= !! See the Syntax Rules.

direct_select_statement_multiple_rows ::= cursor_specification
                                      ;
get_diagnostics_statement ::= GET DIAGNOSTICS SQL_diagnostics_information
                          ;

SQL_diagnostics_information ::= statement_information 
                            |   condition_information
                            ;

statement_information ::= statement_information_item_list
                      ;

statement_information_item_list ::= statement_information_item
                                |   statement_information_item_list COMMA statement_information_item
                                ;

statement_information_item ::= simple_target_specification EQ statement_information_item_name
                           ;

statement_information_item_name ::= NUMBER
                                |   MORE
                                |   COMMAND_FUNCTION
                                |   COMMAND_FUNCTION_CODE
                                |   DYNAMIC_FUNCTION
                                |   DYNAMIC_FUNCTION_CODE
                                |   ROW_COUNT
                                |   TRANSACTIONS_COMMITTED
                                |   TRANSACTIONS_ROLLED_BACK
                                |   TRANSACTION_ACTIVE

condition_information ::= condition_information_type  condition_number condition_information_list
                      ;

condition_information_type ::=  EXCEPTION
                           |    CONDITION
                           ;
                           
condition_information_list ::= condition_information_item                           
                           |   condition_information_list COMMA condition_information_item 
                           ;
                           

condition_information_item ::= simple_target_specification EQ condition_information_item_name
                           ;

condition_information_item_name ::= CATALOG_NAME
                                |   CLASS_ORIGIN
                                |   COLUMN_NAME
                                |   CONDITION_NUMBER
                                |   CONNECTION_NAME
                                |   CONSTRAINT_CATALOG
                                |   CONSTRAINT_NAME
                                |   CONSTRAINT_SCHEMA
                                |   CURSOR_NAME
                                |   MESSAGE_LENGTH
                                |   MESSAGE_OCTET_LENGTH
                                |   MESSAGE_TEXT
                                |   PARAMETER_MODE
                                |   PARAMETER_NAME
                                |   PARAMETER_ORDINAL_POSITION
                                |   RETURNED_SQLSTATE
                                |   ROUTINE_CATALOG
                                |   ROUTINE_NAME
                                |   ROUTINE_SCHEMA
                                |   SCHEMA_NAME
                                |   SERVER_NAME
                                |   SPECIFIC_NAME
                                |   SUBCLASS_ORIGIN
                                |   TABLE_NAME
                                |   TRIGGER_CATALOG
                                |   TRIGGER_NAME
                                |   TRIGGER_SCHEMA
                                ;

condition_number ::= simple_value_specification 
                 ;
 

